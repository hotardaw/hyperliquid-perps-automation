{"version":3,"sources":["../src/index.ts","../src/types/constants.ts","../src/rest/info/general.ts","../src/rest/info/spot.ts","../src/rest/info/perpetuals.ts","../src/utils/helpers.ts","../src/utils/errors.ts","../src/rest/info.ts","../src/rest/exchange.ts","../src/utils/signing.ts","../src/utils/environment.ts","../src/websocket/connection.ts","../src/websocket/subscriptions.ts","../src/websocket/payload-generator.ts","../src/websocket/payload-manager.ts","../src/utils/rateLimiter.ts","../src/rest/custom.ts","../src/utils/symbolConversion.ts"],"sourcesContent":["import { InfoAPI } from './rest/info';\nimport { ExchangeAPI } from './rest/exchange';\nimport { WebSocketClient } from './websocket/connection';\nimport { WebSocketSubscriptions } from './websocket/subscriptions';\nimport {\n  WebSocketPayloadManager,\n  createWebSocketPayloadManager,\n} from './websocket/payload-manager';\nimport { RateLimiter } from './utils/rateLimiter';\nimport * as CONSTANTS from './types/constants';\nimport { CustomOperations } from './rest/custom';\nimport { ethers } from 'ethers';\nimport { SymbolConversion } from './utils/symbolConversion';\nimport { AuthenticationError } from './utils/errors';\nimport { environment } from './utils/environment';\n\nexport interface HyperliquidConfig {\n  enableWs?: boolean;\n  privateKey?: string;\n  testnet?: boolean;\n  walletAddress?: string;\n  vaultAddress?: string;\n  maxReconnectAttempts?: number;\n  disableAssetMapRefresh?: boolean;\n  assetMapRefreshIntervalMs?: number;\n}\n\nexport class Hyperliquid {\n  public info: InfoAPI;\n  public exchange: ExchangeAPI = {} as ExchangeAPI;\n  public ws: WebSocketClient;\n  public subscriptions: WebSocketSubscriptions;\n  public wsPayloads: WebSocketPayloadManager = {} as WebSocketPayloadManager;\n  public custom: CustomOperations;\n  public symbolConversion: SymbolConversion;\n\n  private rateLimiter: RateLimiter;\n  private isValidPrivateKey: boolean = false;\n  private walletAddress: string | null = null;\n  private _initialized: boolean = false;\n  private _initializing: Promise<void> | null = null;\n  private _privateKey?: string;\n  private _walletAddress?: string;\n  private vaultAddress?: string | null = null;\n  private enableWs: boolean;\n  private baseUrl: string;\n  private testnet: boolean;\n\n  constructor(params: HyperliquidConfig = {}) {\n    const {\n      enableWs = true,\n      privateKey,\n      testnet = false,\n      walletAddress,\n      vaultAddress,\n      maxReconnectAttempts,\n      disableAssetMapRefresh = false,\n      assetMapRefreshIntervalMs = 60000,\n    } = params;\n\n    // Browser-specific security warnings\n    if (environment.isBrowser) {\n      if (privateKey) {\n        console.warn(\n          'Warning: Storing private keys in browser environments is not recommended. Consider using a Web3 wallet provider instead.'\n        );\n      }\n      if (!window.isSecureContext) {\n        console.warn('Warning: Running in an insecure context. Some features may be limited.');\n      }\n    }\n\n    this.testnet = testnet;\n    this.baseUrl = testnet ? CONSTANTS.BASE_URLS.TESTNET : CONSTANTS.BASE_URLS.PRODUCTION;\n    this.enableWs = enableWs;\n    this.rateLimiter = new RateLimiter();\n    this.symbolConversion = new SymbolConversion(\n      this.baseUrl,\n      this.rateLimiter,\n      disableAssetMapRefresh,\n      assetMapRefreshIntervalMs\n    );\n    this.walletAddress = walletAddress || null;\n    this.vaultAddress = vaultAddress || null;\n\n    // Initialize REST API clients\n    this.info = new InfoAPI(this.baseUrl, this.rateLimiter, this.symbolConversion, this);\n\n    // Initialize custom operations\n    this.custom = new CustomOperations(this);\n\n    // Initialize WebSocket client if enabled\n    if (enableWs) {\n      if (!environment.hasNativeWebSocket() && environment.isNode) {\n        console.warn(\n          'Native WebSocket support is not available in this Node.js version. Attempting to use ws package...'\n        );\n      }\n\n      // Create WebSocket client - it will attempt to use ws package if native WebSocket is not available\n      this.ws = new WebSocketClient(testnet, maxReconnectAttempts);\n      this.subscriptions = new WebSocketSubscriptions(this.ws, this.symbolConversion);\n\n      // Only disable WebSocket if the client fails to initialize\n      if (!environment.supportsWebSocket()) {\n        console.warn(\n          'WebSocket support is not available. Please install the ws package to enable WebSocket features:\\n\\nnpm install ws\\n'\n        );\n        this.enableWs = false;\n      }\n    } else {\n      // Initialize with dummy objects if WebSocket is disabled\n      this.ws = {} as WebSocketClient;\n      this.subscriptions = {} as WebSocketSubscriptions;\n      this.wsPayloads = {} as WebSocketPayloadManager;\n    }\n\n    // Set up authentication if private key is provided\n    if (privateKey) {\n      this.initializeWithPrivateKey(privateKey, testnet);\n    } else if (walletAddress) {\n      this._walletAddress = walletAddress;\n      this.walletAddress = walletAddress;\n    }\n  }\n\n  public async connect(): Promise<void> {\n    if (!this._initialized) {\n      if (!this._initializing) {\n        this._initializing = this.initialize();\n      }\n      await this._initializing;\n    }\n  }\n\n  private async initialize(): Promise<void> {\n    if (this._initialized) return;\n\n    try {\n      // Note: SymbolConversion will be initialized lazily when first needed\n      // This prevents unnecessary API calls for users who don't need symbol conversion\n\n      // Connect WebSocket if enabled and available\n      if (this.enableWs && this.ws && typeof this.ws.connect === 'function') {\n        try {\n          await this.ws.connect();\n        } catch (wsError: unknown) {\n          const errorMessage = wsError instanceof Error ? wsError.message : String(wsError);\n          console.warn('Failed to establish WebSocket connection:', errorMessage);\n          if (errorMessage.includes('Please install the ws package')) {\n            console.warn('To enable WebSocket support, please run: npm install ws');\n            this.enableWs = false;\n          }\n          // Don't throw here - we want to continue initialization even if WebSocket fails\n        }\n      } else if (this.enableWs) {\n        // WebSocket was requested but not available\n        console.warn('WebSocket was enabled but is not available in this environment');\n        this.enableWs = false;\n      }\n\n      this._initialized = true;\n      this._initializing = null;\n    } catch (error) {\n      this._initializing = null;\n      throw error;\n    }\n  }\n\n  public async ensureInitialized(): Promise<void> {\n    await this.connect();\n  }\n\n  private initializePrivateKey(privateKey: string, testnet: boolean): void {\n    try {\n      const formattedPrivateKey = privateKey.startsWith('0x') ? privateKey : `0x${privateKey}`;\n      new ethers.Wallet(formattedPrivateKey); // Validate the private key\n\n      this.exchange = new ExchangeAPI(\n        testnet,\n        formattedPrivateKey,\n        this.info,\n        this.rateLimiter,\n        this.symbolConversion,\n        this.walletAddress,\n        this,\n        this.vaultAddress\n      );\n\n      this.custom = new CustomOperations(\n        this.exchange,\n        this.info,\n        formattedPrivateKey,\n        this.symbolConversion,\n        this.walletAddress\n      );\n\n      this.isValidPrivateKey = true;\n    } catch (error) {\n      console.warn('Invalid private key provided. Some functionalities will be limited.');\n      this.isValidPrivateKey = false;\n    }\n  }\n\n  private createAuthenticatedProxy<T extends object>(Class: new (...args: any[]) => T): T {\n    return new Proxy({} as T, {\n      get: (target, prop) => {\n        if (!this.isValidPrivateKey) {\n          throw new AuthenticationError(\n            'Invalid or missing private key. This method requires authentication.'\n          );\n        }\n        return target[prop as keyof T];\n      },\n    });\n  }\n\n  private initializeWithPrivateKey(privateKey: string, testnet: boolean = false): void {\n    try {\n      const formattedPrivateKey = privateKey.startsWith('0x')\n        ? privateKey\n        : (`0x${privateKey}` as `0x${string}`);\n      const wallet = new ethers.Wallet(formattedPrivateKey); // Validate the private key\n\n      this.exchange = new ExchangeAPI(\n        testnet,\n        formattedPrivateKey,\n        this.info,\n        this.rateLimiter,\n        this.symbolConversion,\n        this.walletAddress,\n        this,\n        this.vaultAddress\n      );\n      this.custom = new CustomOperations(\n        this.exchange,\n        this.info,\n        formattedPrivateKey,\n        this.symbolConversion,\n        this.walletAddress\n      );\n\n      // Initialize WebSocket payload manager if WebSocket is enabled\n      if (this.enableWs && this.subscriptions) {\n        this.wsPayloads = createWebSocketPayloadManager({\n          wallet,\n          isMainnet: !testnet,\n          symbolConversion: this.symbolConversion,\n          subscriptions: this.subscriptions,\n          vaultAddress: this.vaultAddress,\n          generateNonce: () => Date.now(),\n          customOperations: this.custom,\n        });\n      }\n\n      this.isValidPrivateKey = true;\n    } catch (error) {\n      console.warn('Invalid private key provided. Some functionalities will be limited.');\n      this.isValidPrivateKey = false;\n    }\n  }\n\n  // Modify existing methods to check initialization\n  public isAuthenticated(): boolean {\n    // Don't call ensureInitialized() here as it can cause issues during construction\n    // The authentication state is set during construction and doesn't require async initialization\n    return this.isValidPrivateKey;\n  }\n\n  public isWebSocketConnected(): boolean {\n    return this.enableWs && this.ws && typeof this.ws.isConnected === 'function'\n      ? this.ws.isConnected()\n      : false;\n  }\n\n  public isWebSocketEnabled(): boolean {\n    return this.enableWs && this.ws && typeof this.ws.connect === 'function';\n  }\n\n  disconnect(): void {\n    // Stop the asset map refresh interval\n    this.symbolConversion.stopPeriodicRefresh();\n\n    // Close WebSocket connection if enabled\n    if (this.enableWs && this.ws && typeof this.ws.close === 'function') {\n      this.ws.close(true); // Pass true to indicate manual disconnect\n    }\n\n    // Reset initialization state\n    this._initialized = false;\n    this._initializing = null;\n  }\n\n  public getBaseUrl(): string {\n    return this.baseUrl;\n  }\n\n  public getRateLimiter(): RateLimiter {\n    return this.rateLimiter;\n  }\n\n  // Asset map refresh control methods\n  public enableAssetMapRefresh(): void {\n    this.symbolConversion.enablePeriodicRefresh();\n  }\n\n  public disableAssetMapRefresh(): void {\n    this.symbolConversion.disablePeriodicRefresh();\n  }\n\n  public isAssetMapRefreshEnabled(): boolean {\n    return this.symbolConversion.isRefreshEnabled();\n  }\n\n  public getAssetMapRefreshInterval(): number {\n    return this.symbolConversion.getRefreshInterval();\n  }\n\n  public setAssetMapRefreshInterval(intervalMs: number): void {\n    this.symbolConversion.setRefreshInterval(intervalMs);\n  }\n\n  public async refreshAssetMapsNow(): Promise<void> {\n    await this.symbolConversion.initialize();\n  }\n}\n\nexport * from './types';\nexport * from './utils/signing';\nexport * from './types/constants';\n","export const BASE_URLS = {\n  PRODUCTION: 'https://api.hyperliquid.xyz',\n  TESTNET: 'https://api.hyperliquid-testnet.xyz',\n};\n\nexport const WSS_URLS = {\n  PRODUCTION: 'wss://api.hyperliquid.xyz/ws',\n  TESTNET: 'wss://api.hyperliquid-testnet.xyz/ws',\n};\n\nexport const CHAIN_IDS = {\n  ARBITRUM_MAINNET: '0xa4b1', // 42161\n  ARBITRUM_TESTNET: '0x66eee', // 421614 - testnet//Arbitrum Sepolia\n};\n\nexport const ENDPOINTS = {\n  INFO: '/info',\n  EXCHANGE: '/exchange',\n};\n\nexport enum InfoType {\n  ALL_MIDS = 'allMids',\n  META = 'meta',\n  OPEN_ORDERS = 'openOrders',\n  FRONTEND_OPEN_ORDERS = 'frontendOpenOrders',\n  USER_FILLS = 'userFills',\n  USER_FILLS_BY_TIME = 'userFillsByTime',\n  USER_RATE_LIMIT = 'userRateLimit',\n  ORDER_STATUS = 'orderStatus',\n  L2_BOOK = 'l2Book',\n  CANDLE_SNAPSHOT = 'candleSnapshot',\n  PERPS_META_AND_ASSET_CTXS = 'metaAndAssetCtxs',\n  PERPS_CLEARINGHOUSE_STATE = 'clearinghouseState',\n  USER_FUNDING = 'userFunding',\n  USER_NON_FUNDING_LEDGER_UPDATES = 'userNonFundingLedgerUpdates',\n  FUNDING_HISTORY = 'fundingHistory',\n  SPOT_META = 'spotMeta',\n  SPOT_CLEARINGHOUSE_STATE = 'spotClearinghouseState',\n  SPOT_META_AND_ASSET_CTXS = 'spotMetaAndAssetCtxs',\n  PREDICTED_FUNDINGS = 'predictedFundings',\n  SPOT_DEPLOY_STATE = 'spotDeployState',\n  TOKEN_DETAILS = 'tokenDetails',\n  MAX_BUILDER_FEE = 'maxBuilderFee',\n  HISTORICAL_ORDERS = 'historicalOrders',\n  USER_TWAP_SLICE_FILLS = 'userTwapSliceFills',\n  SUB_ACCOUNTS = 'subAccounts',\n  VAULT_DETAILS = 'vaultDetails',\n  USER_VAULT_EQUITIES = 'userVaultEquities',\n  USER_ROLE = 'userRole',\n  DELEGATIONS = 'delegations',\n  DELEGATOR_SUMMARY = 'delegatorSummary',\n  PERPS_AT_OPEN_INTEREST_CAP = 'perpsAtOpenInterestCap',\n  DELEGATOR_HISTORY = 'delegatorHistory',\n  DELEGATOR_REWARDS = 'delegatorRewards',\n  VALIDATOR_SUMMARIES = 'validatorSummaries',\n  VAULT_SUMMARIES = 'vaultSummaries',\n  BLOCK_DETAILS = 'blockDetails',\n  TX_DETAILS = 'txDetails',\n  USER_DETAILS = 'userDetails',\n  USER_FEES = 'userFees',\n  PORTFOLIO = 'portfolio',\n  PRE_TRANSFER_CHECK = 'preTransferCheck',\n  REFERRAL = 'referral',\n  EXTRA_AGENTS = 'extraAgents',\n  IS_VIP = 'isVip',\n  LEGAL_CHECK = 'legalCheck',\n  USER_TWAP_SLICE_FILLS_BY_TIME = 'userTwapSliceFillsByTime',\n  TWAP_HISTORY = 'twapHistory',\n  USER_TO_MULTI_SIG_SIGNERS = 'userToMultiSigSigners',\n  BUILDER_FEE_APPROVAL = 'builderFeeApproval',\n  USER_ORDER_HISTORY = 'userOrderHistory',\n  PERP_DEX_LIMITS = 'perpDexLimits',\n}\n\nexport enum ExchangeType {\n  ORDER = 'order',\n  CANCEL = 'cancel',\n  CANCEL_BY_CLOID = 'cancelByCloid',\n  SCHEDULE_CANCEL = 'scheduleCancel',\n  MODIFY = 'modify',\n  BATCH_MODIFY = 'batchModify',\n  UPDATE_LEVERAGE = 'updateLeverage',\n  UPDATE_ISOLATED_MARGIN = 'updateIsolatedMargin',\n  USD_SEND = 'usdSend',\n  SPOT_SEND = 'spotSend',\n  WITHDRAW = 'withdraw3',\n  SPOT_USER = 'spotUser',\n  VAULT_TRANSFER = 'vaultTransfer',\n  CREATE_VAULT = 'createVault',\n  VAULT_DISTRIBUTE = 'vaultDistribute',\n  VAULT_MODIFY = 'vaultModify',\n  SET_REFERRER = 'setReferrer',\n  REGISTER_REFERRER = 'registerReferrer',\n  USD_CLASS_TRANSFER = 'usdClassTransfer',\n  TWAP_ORDER = 'twapOrder',\n  TWAP_CANCEL = 'twapCancel',\n  APPROVE_AGENT = 'approveAgent',\n  APPROVE_BUILDER_FEE = 'approveBuilderFee',\n  EVM_USER_MODIFY = 'evmUserModify',\n  CLAIM_REWARDS = 'claimRewards',\n  CREATE_SUB_ACCOUNT = 'createSubAccount',\n  SET_DISPLAY_NAME = 'setDisplayName',\n  C_DEPOSIT = 'cDeposit',\n  C_WITHDRAW = 'cWithdraw',\n  TOKEN_DELEGATE = 'tokenDelegate',\n  SUB_ACCOUNT_SPOT_TRANSFER = 'subAccountSpotTransfer',\n  SUB_ACCOUNT_TRANSFER = 'subAccountTransfer',\n  RESERVE_REQUEST_WEIGHT = 'reserveRequestWeight',\n  NOOP = 'noop',\n}\n\nexport const WEBSOCKET = {\n  MAINNET_URL: 'wss://api.hyperliquid.xyz/ws',\n  TESTNET_URL: 'wss://api.hyperliquid-testnet.xyz/ws',\n};\n\nexport const SDK_CODE = 'PLACEHOLDER';\n","// src/rest/info/general.ts\n\nimport {\n  AllMids,\n  UserOpenOrders,\n  FrontendOpenOrders,\n  UserFills,\n  UserRateLimit,\n  OrderStatus,\n  L2Book,\n  CandleSnapshot,\n  HistoricalOrder,\n  TwapSliceFill,\n  SubAccount,\n  VaultDetails,\n  VaultEquity,\n  UserRole,\n  Delegation,\n  DelegatorSummary,\n  DelegatorHistoryEntry,\n  DelegatorReward,\n  ValidatorSummary,\n  VaultSummary,\n  UserFees,\n  PortfolioPeriods,\n  PreTransferCheck,\n  Referral,\n  ExtraAgent,\n  LegalCheck,\n  TwapHistory,\n  MultiSigSigners,\n  BuilderFeeApproval,\n  UserOrderHistory,\n} from '../../types';\nimport { HttpApi } from '../../utils/helpers';\nimport { SymbolConversion } from '../../utils/symbolConversion';\nimport { InfoType } from '../../types/constants';\nimport { Hyperliquid } from '../../index';\n\nexport class GeneralInfoAPI {\n  private parent: Hyperliquid;\n\n  constructor(\n    private httpApi: HttpApi,\n    private symbolConversion: SymbolConversion,\n    parent: Hyperliquid\n  ) {\n    this.parent = parent;\n  }\n\n  async getAllMids(rawResponse: boolean = false): Promise<AllMids> {\n    const response = await this.httpApi.makeRequest<AllMids>({ type: InfoType.ALL_MIDS });\n\n    if (rawResponse) {\n      return response;\n    } else {\n      const convertedResponse: any = {};\n      for (const [key, value] of Object.entries(response)) {\n        const convertedKey = await this.symbolConversion.convertSymbol(key);\n        const convertedValue = parseFloat(value as string);\n        convertedResponse[convertedKey] = convertedValue;\n      }\n      return convertedResponse;\n    }\n  }\n\n  async getUserOpenOrders(user: string, rawResponse: boolean = false): Promise<UserOpenOrders> {\n    await this.parent.ensureInitialized();\n    const response = await this.httpApi.makeRequest<UserOpenOrders>({\n      type: InfoType.OPEN_ORDERS,\n      user: user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getFrontendOpenOrders(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<FrontendOpenOrders> {\n    const response = await this.httpApi.makeRequest<FrontendOpenOrders>(\n      { type: InfoType.FRONTEND_OPEN_ORDERS, user: user },\n      20\n    );\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getUserFills(user: string, rawResponse: boolean = false): Promise<UserFills> {\n    const response = await this.httpApi.makeRequest<UserFills>(\n      { type: InfoType.USER_FILLS, user: user },\n      20\n    );\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getUserFillsByTime(\n    user: string,\n    startTime: number,\n    endTime?: number,\n    rawResponse: boolean = false\n  ): Promise<UserFills> {\n    let params: { user: string; startTime: number; type: string; endTime?: number } = {\n      user: user,\n      startTime: Math.round(startTime),\n      type: InfoType.USER_FILLS_BY_TIME,\n    };\n\n    if (endTime) {\n      params.endTime = Math.round(endTime);\n    }\n\n    const response = await this.httpApi.makeRequest<UserFills>(params, 20);\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getUserRateLimit(user: string, rawResponse: boolean = false): Promise<UserRateLimit> {\n    const response = await this.httpApi.makeRequest<UserRateLimit>(\n      { type: InfoType.USER_RATE_LIMIT, user: user },\n      20\n    );\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getOrderStatus(\n    user: string,\n    oid: number | string,\n    rawResponse: boolean = false\n  ): Promise<OrderStatus> {\n    const response = await this.httpApi.makeRequest<OrderStatus>({\n      type: InfoType.ORDER_STATUS,\n      user: user,\n      oid: oid,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getL2Book(\n    coin: string,\n    rawResponse: boolean = false,\n    nSigFigs: number = 5,\n    mantissa?: number\n  ): Promise<L2Book> {\n    const response = await this.httpApi.makeRequest<L2Book>({\n      type: InfoType.L2_BOOK,\n      coin: await this.symbolConversion.convertSymbol(coin, 'reverse'),\n      nSigFigs,\n      mantissa,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getCandleSnapshot(\n    coin: string,\n    interval: string,\n    startTime: number,\n    endTime: number,\n    rawResponse: boolean = false\n  ): Promise<CandleSnapshot> {\n    const response = await this.httpApi.makeRequest<CandleSnapshot>({\n      type: InfoType.CANDLE_SNAPSHOT,\n      req: {\n        coin: await this.symbolConversion.convertSymbol(coin, 'reverse'),\n        interval: interval,\n        startTime: startTime,\n        endTime: endTime,\n      },\n    });\n\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response, ['s']);\n  }\n\n  // Add these methods to src/rest/info/general.ts\n\n  async getMaxBuilderFee(\n    user: string,\n    builder: string,\n    rawResponse: boolean = false\n  ): Promise<number> {\n    const response = await this.httpApi.makeRequest<number>({\n      type: InfoType.MAX_BUILDER_FEE,\n      user,\n      builder,\n    });\n    return rawResponse ? response : this.symbolConversion.convertToNumber(response);\n  }\n\n  async getHistoricalOrders(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<HistoricalOrder[]> {\n    const response = await this.httpApi.makeRequest<HistoricalOrder[]>({\n      type: InfoType.HISTORICAL_ORDERS,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getUserTwapSliceFills(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<TwapSliceFill[]> {\n    const response = await this.httpApi.makeRequest<TwapSliceFill[]>({\n      type: InfoType.USER_TWAP_SLICE_FILLS,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getSubAccounts(user: string, rawResponse: boolean = false): Promise<SubAccount[]> {\n    const response = await this.httpApi.makeRequest<SubAccount[]>({\n      type: InfoType.SUB_ACCOUNTS,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getVaultDetails(\n    vaultAddress: string,\n    user?: string,\n    rawResponse: boolean = false\n  ): Promise<VaultDetails> {\n    const params: any = {\n      type: InfoType.VAULT_DETAILS,\n      vaultAddress,\n    };\n\n    if (user) {\n      params.user = user;\n    }\n\n    const response = await this.httpApi.makeRequest<VaultDetails>(params);\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getUserVaultEquities(user: string, rawResponse: boolean = false): Promise<VaultEquity[]> {\n    const response = await this.httpApi.makeRequest<VaultEquity[]>({\n      type: InfoType.USER_VAULT_EQUITIES,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getUserRole(user: string, rawResponse: boolean = false): Promise<UserRole> {\n    const response = await this.httpApi.makeRequest<UserRole>({\n      type: InfoType.USER_ROLE,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getDelegations(user: string, rawResponse: boolean = false): Promise<Delegation[]> {\n    const response = await this.httpApi.makeRequest<Delegation[]>({\n      type: InfoType.DELEGATIONS,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getDelegatorSummary(user: string, rawResponse: boolean = false): Promise<DelegatorSummary> {\n    const response = await this.httpApi.makeRequest<DelegatorSummary>({\n      type: InfoType.DELEGATOR_SUMMARY,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getDelegatorHistory(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<DelegatorHistoryEntry[]> {\n    const response = await this.httpApi.makeRequest<DelegatorHistoryEntry[]>({\n      type: InfoType.DELEGATOR_HISTORY,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getDelegatorRewards(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<DelegatorReward[]> {\n    const response = await this.httpApi.makeRequest<DelegatorReward[]>({\n      type: InfoType.DELEGATOR_REWARDS,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async validatorSummaries(rawResponse: boolean = false): Promise<ValidatorSummary[]> {\n    const response = await this.httpApi.makeRequest<ValidatorSummary[]>({\n      type: InfoType.VALIDATOR_SUMMARIES,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async vaultSummaries(rawResponse: boolean = false): Promise<VaultSummary[]> {\n    const response = await this.httpApi.makeRequest<VaultSummary[]>({\n      type: InfoType.VAULT_SUMMARIES,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async userFees(user: string, rawResponse: boolean = false): Promise<UserFees> {\n    const response = await this.httpApi.makeRequest<UserFees>({\n      type: InfoType.USER_FEES,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async portfolio(user: string, rawResponse: boolean = false): Promise<PortfolioPeriods> {\n    const response = await this.httpApi.makeRequest<PortfolioPeriods>({\n      type: InfoType.PORTFOLIO,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async preTransferCheck(\n    user: string,\n    source: string,\n    rawResponse: boolean = false\n  ): Promise<PreTransferCheck> {\n    const response = await this.httpApi.makeRequest<PreTransferCheck>({\n      type: InfoType.PRE_TRANSFER_CHECK,\n      user,\n      source,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async referral(user: string, rawResponse: boolean = false): Promise<Referral> {\n    const response = await this.httpApi.makeRequest<Referral>({\n      type: InfoType.REFERRAL,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async extraAgents(user: string, rawResponse: boolean = false): Promise<ExtraAgent[]> {\n    const response = await this.httpApi.makeRequest<ExtraAgent[]>({\n      type: InfoType.EXTRA_AGENTS,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async isVip(user: string, rawResponse: boolean = false): Promise<boolean> {\n    const response = await this.httpApi.makeRequest<boolean>({\n      type: InfoType.IS_VIP,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async legalCheck(user: string, rawResponse: boolean = false): Promise<LegalCheck> {\n    const response = await this.httpApi.makeRequest<LegalCheck>({\n      type: InfoType.LEGAL_CHECK,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async userTwapSliceFillsByTime(\n    user: string,\n    startTime: number,\n    endTime?: number,\n    aggregateByTime?: boolean,\n    rawResponse: boolean = false\n  ): Promise<TwapSliceFill[]> {\n    const params: any = {\n      type: InfoType.USER_TWAP_SLICE_FILLS_BY_TIME,\n      user,\n      startTime,\n    };\n\n    if (endTime !== undefined) params.endTime = endTime;\n    if (aggregateByTime !== undefined) params.aggregateByTime = aggregateByTime;\n\n    const response = await this.httpApi.makeRequest<TwapSliceFill[]>(params);\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async twapHistory(user: string, rawResponse: boolean = false): Promise<TwapHistory[]> {\n    const response = await this.httpApi.makeRequest<TwapHistory[]>({\n      type: InfoType.TWAP_HISTORY,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async userToMultiSigSigners(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<MultiSigSigners | null> {\n    const response = await this.httpApi.makeRequest<MultiSigSigners | null>({\n      type: InfoType.USER_TO_MULTI_SIG_SIGNERS,\n      user,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getBuilderFeeApproval(\n    user: string,\n    builderAddress: string,\n    rawResponse: boolean = false\n  ): Promise<BuilderFeeApproval> {\n    const response = await this.httpApi.makeRequest<BuilderFeeApproval>({\n      type: InfoType.BUILDER_FEE_APPROVAL,\n      user,\n      builderAddress,\n    });\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getUserOrderHistory(\n    user: string,\n    startTime: number,\n    endTime?: number,\n    rawResponse: boolean = false\n  ): Promise<UserOrderHistory> {\n    const params: any = {\n      type: InfoType.USER_ORDER_HISTORY,\n      user,\n      startTime: Math.round(startTime),\n    };\n\n    if (endTime !== undefined) {\n      params.endTime = Math.round(endTime);\n    }\n\n    const response = await this.httpApi.makeRequest<UserOrderHistory>(params, 20);\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n}\n","import { SpotMeta, SpotClearinghouseState, SpotMetaAndAssetCtxs } from '../../types';\nimport { HttpApi } from '../../utils/helpers';\nimport { InfoType } from '../../types/constants';\nimport { SymbolConversion } from '../../utils/symbolConversion';\n\nexport class SpotInfoAPI {\n  private httpApi: HttpApi;\n  private symbolConversion: SymbolConversion;\n\n  constructor(httpApi: HttpApi, symbolConversion: SymbolConversion) {\n    this.httpApi = httpApi;\n    this.symbolConversion = symbolConversion;\n  }\n\n  async getSpotMeta(rawResponse: boolean = false): Promise<SpotMeta> {\n    const response = await this.httpApi.makeRequest({ type: InfoType.SPOT_META });\n    return rawResponse\n      ? (response as SpotMeta)\n      : ((await this.symbolConversion.convertResponse(\n          response,\n          ['name', 'coin', 'symbol'],\n          'SPOT'\n        )) as SpotMeta);\n  }\n\n  async getSpotClearinghouseState(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<SpotClearinghouseState> {\n    const response = await this.httpApi.makeRequest({\n      type: InfoType.SPOT_CLEARINGHOUSE_STATE,\n      user: user,\n    });\n    return rawResponse\n      ? (response as SpotClearinghouseState)\n      : ((await this.symbolConversion.convertResponse(\n          response,\n          ['name', 'coin', 'symbol'],\n          'SPOT'\n        )) as SpotClearinghouseState);\n  }\n\n  async getSpotMetaAndAssetCtxs(rawResponse: boolean = false): Promise<SpotMetaAndAssetCtxs> {\n    const response = await this.httpApi.makeRequest({ type: InfoType.SPOT_META_AND_ASSET_CTXS });\n    return rawResponse\n      ? (response as SpotMetaAndAssetCtxs)\n      : ((await this.symbolConversion.convertResponse(response)) as SpotMetaAndAssetCtxs);\n  }\n\n  async getTokenDetails(tokenId: string, rawResponse: boolean = false): Promise<any> {\n    const response = await this.httpApi.makeRequest(\n      {\n        type: InfoType.TOKEN_DETAILS,\n        tokenId: tokenId,\n      },\n      20\n    );\n\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n\n  async getSpotDeployState(user: string, rawResponse: boolean = false): Promise<any> {\n    const response = await this.httpApi.makeRequest(\n      {\n        type: InfoType.SPOT_DEPLOY_STATE,\n        user: user,\n      },\n      20\n    );\n\n    return rawResponse ? response : await this.symbolConversion.convertResponse(response);\n  }\n}\n","import {\n  Meta,\n  MetaAndAssetCtxs,\n  ClearinghouseState,\n  UserFunding,\n  UserNonFundingLedgerUpdates,\n  FundingHistory,\n  PredictedFundings,\n  PerpsAtOpenInterestCap,\n  PerpDexLimits,\n} from '../../types';\nimport { HttpApi } from '../../utils/helpers';\nimport { InfoType } from '../../types/constants';\nimport { SymbolConversion } from '../../utils/symbolConversion';\nimport { Hyperliquid } from '../../index';\n\nexport class PerpetualsInfoAPI {\n  private httpApi: HttpApi;\n  private symbolConversion: SymbolConversion;\n  private parent: Hyperliquid;\n\n  constructor(httpApi: HttpApi, symbolConversion: SymbolConversion, parent: Hyperliquid) {\n    this.httpApi = httpApi;\n    this.symbolConversion = symbolConversion;\n    this.parent = parent;\n  }\n\n  async getMeta(rawResponse: boolean = false): Promise<Meta> {\n    const response = await this.httpApi.makeRequest({ type: InfoType.META });\n    return rawResponse\n      ? (response as Meta)\n      : ((await this.symbolConversion.convertResponse(\n          response,\n          ['name', 'coin', 'symbol'],\n          'PERP'\n        )) as Meta);\n  }\n\n  async getMetaAndAssetCtxs(rawResponse: boolean = false): Promise<MetaAndAssetCtxs> {\n    const response = await this.httpApi.makeRequest({ type: InfoType.PERPS_META_AND_ASSET_CTXS });\n    return rawResponse\n      ? (response as MetaAndAssetCtxs)\n      : ((await this.symbolConversion.convertResponse(\n          response,\n          ['name', 'coin', 'symbol'],\n          'PERP'\n        )) as MetaAndAssetCtxs);\n  }\n\n  async getClearinghouseState(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<ClearinghouseState> {\n    const response = await this.httpApi.makeRequest({\n      type: InfoType.PERPS_CLEARINGHOUSE_STATE,\n      user: user,\n    });\n    return rawResponse\n      ? (response as ClearinghouseState)\n      : ((await this.symbolConversion.convertResponse(response)) as ClearinghouseState);\n  }\n\n  async getUserFunding(\n    user: string,\n    startTime: number,\n    endTime?: number,\n    rawResponse: boolean = false\n  ): Promise<UserFunding> {\n    const response = await this.httpApi.makeRequest(\n      {\n        type: InfoType.USER_FUNDING,\n        user: user,\n        startTime: startTime,\n        endTime: endTime,\n      },\n      20\n    );\n    return rawResponse\n      ? (response as UserFunding)\n      : ((await this.symbolConversion.convertResponse(response)) as UserFunding);\n  }\n\n  async getUserNonFundingLedgerUpdates(\n    user: string,\n    startTime: number,\n    endTime?: number,\n    rawResponse: boolean = false\n  ): Promise<UserNonFundingLedgerUpdates> {\n    const response = await this.httpApi.makeRequest(\n      {\n        type: InfoType.USER_NON_FUNDING_LEDGER_UPDATES,\n        user: user,\n        startTime: startTime,\n        endTime: endTime,\n      },\n      20\n    );\n    return rawResponse\n      ? (response as UserNonFundingLedgerUpdates)\n      : ((await this.symbolConversion.convertResponse(response)) as UserNonFundingLedgerUpdates);\n  }\n\n  async getFundingHistory(\n    coin: string,\n    startTime: number,\n    endTime?: number,\n    rawResponse: boolean = false\n  ): Promise<FundingHistory> {\n    await this.parent.ensureInitialized();\n    const response = await this.httpApi.makeRequest(\n      {\n        type: InfoType.FUNDING_HISTORY,\n        coin: await this.symbolConversion.convertSymbol(coin, 'reverse'),\n        startTime: startTime,\n        endTime: endTime,\n      },\n      20\n    );\n    return rawResponse\n      ? (response as FundingHistory)\n      : ((await this.symbolConversion.convertResponse(response)) as FundingHistory);\n  }\n\n  async getPredictedFundings(rawResponse: boolean = false): Promise<PredictedFundings> {\n    const response = await this.httpApi.makeRequest(\n      {\n        type: InfoType.PREDICTED_FUNDINGS,\n      },\n      20\n    );\n\n    return rawResponse\n      ? (response as PredictedFundings)\n      : ((await this.symbolConversion.convertResponse(response)) as PredictedFundings);\n  }\n\n  async getPerpsAtOpenInterestCap(rawResponse: boolean = false): Promise<PerpsAtOpenInterestCap> {\n    const response = (await this.httpApi.makeRequest({\n      type: InfoType.PERPS_AT_OPEN_INTEREST_CAP,\n    })) as string[];\n\n    if (rawResponse) {\n      return response;\n    }\n\n    // Convert each symbol in the array\n    const convertedResponse = await Promise.all(\n      response.map((symbol: string) => this.symbolConversion.convertSymbol(symbol, '', 'PERP'))\n    );\n\n    return convertedResponse;\n  }\n\n  async getPerpDexLimits(dex: string, rawResponse: boolean = false): Promise<PerpDexLimits> {\n    const response = await this.httpApi.makeRequest({\n      type: InfoType.PERP_DEX_LIMITS,\n      dex: dex,\n    });\n\n    if (rawResponse) {\n      return response as PerpDexLimits;\n    }\n\n    // Convert coin symbols in coinToOiCap array if needed\n    const responseData = response as PerpDexLimits;\n    const convertedResponse: PerpDexLimits = {\n      totalOiCap: responseData.totalOiCap,\n      oiSzCapPerPerp: responseData.oiSzCapPerPerp,\n      maxTransferNtl: responseData.maxTransferNtl,\n      coinToOiCap: responseData.coinToOiCap,\n    };\n\n    if (convertedResponse.coinToOiCap) {\n      convertedResponse.coinToOiCap = await Promise.all(\n        convertedResponse.coinToOiCap.map(async ([coin, cap]) => [\n          await this.symbolConversion.convertSymbol(coin, '', 'PERP'),\n          cap,\n        ])\n      );\n    }\n\n    return convertedResponse;\n  }\n}\n","import axios, { AxiosInstance } from 'axios';\nimport { handleApiError } from './errors';\nimport { RateLimiter } from './rateLimiter';\n\nexport class HttpApi {\n  private client: AxiosInstance;\n  private endpoint: string;\n  private rateLimiter: RateLimiter;\n\n  constructor(baseUrl: string, endpoint: string = '/', rateLimiter: RateLimiter) {\n    this.endpoint = endpoint;\n    this.client = axios.create({\n      baseURL: baseUrl,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n    this.rateLimiter = rateLimiter;\n  }\n\n  async makeRequest<T>(\n    payload: any,\n    weight: number = 2,\n    endpoint: string = this.endpoint\n  ): Promise<T> {\n    try {\n      await this.rateLimiter.waitForToken(weight);\n\n      const response = await this.client.post(endpoint, payload);\n\n      // Check if response data is null or undefined before returning\n      if (response.data === null || response.data === undefined) {\n        throw new Error('Received null or undefined response data');\n      }\n\n      return response.data;\n    } catch (error) {\n      handleApiError(error);\n    }\n  }\n}\n","export class HyperliquidAPIError extends Error {\n  constructor(\n    public code: string,\n    message: string\n  ) {\n    super(message);\n    this.name = 'HyperliquidAPIError';\n  }\n}\n\nexport class AuthenticationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'AuthenticationError';\n  }\n}\n\nexport function handleApiError(error: any): never {\n  if (error.response) {\n    // The request was made and the server responded with a status code\n    // that falls out of the range of 2xx\n    const errorCode =\n      error.response.data && error.response.data.code\n        ? error.response.data.code\n        : error.response.status || 'UNKNOWN_ERROR';\n\n    const errorMessage = error.response.data\n      ? error.response.data.message ||\n        (typeof error.response.data === 'string'\n          ? error.response.data\n          : 'An unknown error occurred')\n      : 'An unknown error occurred';\n\n    throw new HyperliquidAPIError(errorCode, errorMessage);\n  } else if (error.request) {\n    // The request was made but no response was received\n    throw new HyperliquidAPIError('NETWORK_ERROR', 'No response received from the server');\n  } else {\n    // Something happened in setting up the request that triggered an Error\n    throw new HyperliquidAPIError('REQUEST_SETUP_ERROR', error.message || 'Unknown error occurred');\n  }\n}\n","import { RateLimiter } from '../utils/rateLimiter';\nimport { GeneralInfoAPI } from './info/general';\nimport { SpotInfoAPI } from './info/spot';\nimport { PerpetualsInfoAPI } from './info/perpetuals';\nimport { HttpApi } from '../utils/helpers';\nimport { SymbolConversion } from '../utils/symbolConversion';\nimport { Hyperliquid } from '../index';\n\nimport {\n  AllMids,\n  Meta,\n  UserOpenOrders,\n  FrontendOpenOrders,\n  UserFills,\n  UserRateLimit,\n  OrderStatus,\n  L2Book,\n  CandleSnapshot,\n  VaultEquity,\n  HistoricalOrder,\n  TwapSliceFill,\n  SubAccount,\n  VaultDetails,\n  DelegatorReward,\n  DelegatorHistoryEntry,\n  DelegatorSummary,\n  Delegation,\n  UserRole,\n  ValidatorSummary,\n  VaultSummary,\n  UserFees,\n  PortfolioPeriods,\n  PreTransferCheck,\n  Referral,\n  ExtraAgent,\n  LegalCheck,\n  TwapHistory,\n  MultiSigSigners,\n  BuilderFeeApproval,\n  UserOrderHistory,\n} from '../types/index';\n\nimport { InfoType, ENDPOINTS } from '../types/constants';\n\nexport class InfoAPI {\n  public spot: SpotInfoAPI;\n  public perpetuals: PerpetualsInfoAPI;\n  private httpApi: HttpApi;\n  private generalAPI: GeneralInfoAPI;\n  private symbolConversion: SymbolConversion;\n  private parent: Hyperliquid;\n\n  constructor(\n    baseURL: string,\n    rateLimiter: RateLimiter,\n    symbolConversion: SymbolConversion,\n    parent: Hyperliquid\n  ) {\n    this.httpApi = new HttpApi(baseURL, ENDPOINTS.INFO, rateLimiter);\n    this.symbolConversion = symbolConversion;\n    this.parent = parent;\n\n    this.generalAPI = new GeneralInfoAPI(this.httpApi, this.symbolConversion, this.parent);\n    this.spot = new SpotInfoAPI(this.httpApi, this.symbolConversion);\n    this.perpetuals = new PerpetualsInfoAPI(this.httpApi, this.symbolConversion, this.parent);\n  }\n\n  async getAssetIndex(assetName: string): Promise<number | undefined> {\n    await this.parent.ensureInitialized();\n    return await this.symbolConversion.getAssetIndex(assetName);\n  }\n\n  async getInternalName(exchangeName: string): Promise<string | undefined> {\n    await this.parent.ensureInitialized();\n    return await this.symbolConversion.convertSymbol(exchangeName);\n  }\n\n  async getAllAssets(): Promise<{ perp: string[]; spot: string[] }> {\n    await this.parent.ensureInitialized();\n    return await this.symbolConversion.getAllAssets();\n  }\n\n  async getAllMids(rawResponse: boolean = false): Promise<AllMids> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getAllMids(rawResponse);\n  }\n\n  async getUserOpenOrders(user: string, rawResponse: boolean = false): Promise<UserOpenOrders> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getUserOpenOrders(user, rawResponse);\n  }\n\n  async getFrontendOpenOrders(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<FrontendOpenOrders> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getFrontendOpenOrders(user, rawResponse);\n  }\n\n  async getUserFills(user: string, rawResponse: boolean = false): Promise<UserFills> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getUserFills(user, rawResponse);\n  }\n\n  async getUserFillsByTime(\n    user: string,\n    startTime: number,\n    endTime: number,\n    rawResponse: boolean = false\n  ): Promise<UserFills> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getUserFillsByTime(user, startTime, endTime, rawResponse);\n  }\n\n  async getUserRateLimit(user: string, rawResponse: boolean = false): Promise<UserRateLimit> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getUserRateLimit(user, rawResponse);\n  }\n\n  async getOrderStatus(\n    user: string,\n    oid: number | string,\n    rawResponse: boolean = false\n  ): Promise<OrderStatus> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getOrderStatus(user, oid, rawResponse);\n  }\n\n  async getL2Book(\n    coin: string,\n    rawResponse: boolean = false,\n    nSigFigs: number = 5,\n    mantissa?: number\n  ): Promise<L2Book> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getL2Book(coin, rawResponse, nSigFigs, mantissa);\n  }\n\n  async getCandleSnapshot(\n    coin: string,\n    interval: string,\n    startTime: number,\n    endTime: number,\n    rawResponse: boolean = false\n  ): Promise<CandleSnapshot> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getCandleSnapshot(coin, interval, startTime, endTime, rawResponse);\n  }\n\n  async getMaxBuilderFee(\n    user: string,\n    builder: string,\n    rawResponse: boolean = false\n  ): Promise<number> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getMaxBuilderFee(user, builder, rawResponse);\n  }\n\n  async getHistoricalOrders(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<HistoricalOrder[]> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getHistoricalOrders(user, rawResponse);\n  }\n\n  async getUserTwapSliceFills(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<TwapSliceFill[]> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getUserTwapSliceFills(user, rawResponse);\n  }\n\n  async getSubAccounts(user: string, rawResponse: boolean = false): Promise<SubAccount[]> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getSubAccounts(user, rawResponse);\n  }\n\n  async getVaultDetails(\n    vaultAddress: string,\n    user?: string,\n    rawResponse: boolean = false\n  ): Promise<VaultDetails> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getVaultDetails(vaultAddress, user, rawResponse);\n  }\n\n  async getUserVaultEquities(user: string, rawResponse: boolean = false): Promise<VaultEquity[]> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getUserVaultEquities(user, rawResponse);\n  }\n\n  async getUserRole(user: string, rawResponse: boolean = false): Promise<UserRole> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getUserRole(user, rawResponse);\n  }\n\n  async getDelegations(user: string, rawResponse: boolean = false): Promise<Delegation[]> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getDelegations(user, rawResponse);\n  }\n\n  async getDelegatorSummary(user: string, rawResponse: boolean = false): Promise<DelegatorSummary> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getDelegatorSummary(user, rawResponse);\n  }\n\n  async getDelegatorHistory(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<DelegatorHistoryEntry[]> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getDelegatorHistory(user, rawResponse);\n  }\n\n  async getDelegatorRewards(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<DelegatorReward[]> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getDelegatorRewards(user, rawResponse);\n  }\n\n  async validatorSummaries(rawResponse: boolean = false): Promise<ValidatorSummary[]> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.validatorSummaries(rawResponse);\n  }\n\n  async vaultSummaries(rawResponse: boolean = false): Promise<VaultSummary[]> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.vaultSummaries(rawResponse);\n  }\n\n  async userFees(user: string, rawResponse: boolean = false): Promise<UserFees> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.userFees(user, rawResponse);\n  }\n\n  async portfolio(user: string, rawResponse: boolean = false): Promise<PortfolioPeriods> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.portfolio(user, rawResponse);\n  }\n\n  async preTransferCheck(\n    user: string,\n    source: string,\n    rawResponse: boolean = false\n  ): Promise<PreTransferCheck> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.preTransferCheck(user, source, rawResponse);\n  }\n\n  async referral(user: string, rawResponse: boolean = false): Promise<Referral> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.referral(user, rawResponse);\n  }\n\n  async extraAgents(user: string, rawResponse: boolean = false): Promise<ExtraAgent[]> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.extraAgents(user, rawResponse);\n  }\n\n  async isVip(user: string, rawResponse: boolean = false): Promise<boolean> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.isVip(user, rawResponse);\n  }\n\n  async legalCheck(user: string, rawResponse: boolean = false): Promise<LegalCheck> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.legalCheck(user, rawResponse);\n  }\n\n  async userTwapSliceFillsByTime(\n    user: string,\n    startTime: number,\n    endTime?: number,\n    aggregateByTime?: boolean,\n    rawResponse: boolean = false\n  ): Promise<TwapSliceFill[]> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.userTwapSliceFillsByTime(\n      user,\n      startTime,\n      endTime,\n      aggregateByTime,\n      rawResponse\n    );\n  }\n\n  async twapHistory(user: string, rawResponse: boolean = false): Promise<TwapHistory[]> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.twapHistory(user, rawResponse);\n  }\n\n  async userToMultiSigSigners(\n    user: string,\n    rawResponse: boolean = false\n  ): Promise<MultiSigSigners | null> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.userToMultiSigSigners(user, rawResponse);\n  }\n\n  async getBuilderFeeApproval(\n    user: string,\n    builderAddress: string,\n    rawResponse: boolean = false\n  ): Promise<BuilderFeeApproval> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getBuilderFeeApproval(user, builderAddress, rawResponse);\n  }\n\n  async getUserOrderHistory(\n    user: string,\n    startTime: number,\n    endTime?: number,\n    rawResponse: boolean = false\n  ): Promise<UserOrderHistory> {\n    await this.parent.ensureInitialized();\n    return this.generalAPI.getUserOrderHistory(user, startTime, endTime, rawResponse);\n  }\n}\n","import { ethers } from 'ethers';\nimport { RateLimiter } from '../utils/rateLimiter';\nimport { HttpApi } from '../utils/helpers';\nimport { InfoAPI } from './info';\nimport {\n  signL1Action,\n  orderToWire,\n  orderWireToAction,\n  CancelOrderResponse,\n  signUserSignedAction,\n  signUsdTransferAction,\n  signWithdrawFromBridgeAction,\n  signAgent,\n  removeTrailingZeros,\n} from '../utils/signing';\nimport * as CONSTANTS from '../types/constants';\n\nimport {\n  Builder,\n  CancelOrderRequest,\n  Grouping,\n  Order,\n  OrderRequest,\n  MultiOrder,\n  BulkOrderRequest,\n  TwapCancelRequest,\n  TwapCancelResponse,\n  TwapOrder,\n  TwapOrderResponse,\n  ApproveAgentRequest,\n  ApproveBuilderFeeRequest,\n  CreateVaultRequest,\n  CreateVaultResponse,\n  VaultDistributeRequest,\n  VaultModifyRequest,\n  CreateSubAccountResponse,\n  ClaimRewardsResponse,\n  SetDisplayNameResponse,\n  SpotUserResponse,\n  CDepositResponse,\n  CWithdrawResponse,\n  TokenDelegateResponse,\n  SubAccountSpotTransferResponse,\n  SubAccountTransferResponse,\n  ReserveRequestWeightRequest,\n  ReserveRequestWeightResponse,\n  NoopResponse,\n} from '../types/index';\n\nimport { ExchangeType, ENDPOINTS, CHAIN_IDS } from '../types/constants';\nimport { SymbolConversion } from '../utils/symbolConversion';\nimport { Hyperliquid } from '../index';\n\n// const IS_MAINNET = true; // Make sure this matches the IS_MAINNET in signing.ts\n\nexport class ExchangeAPI {\n  private wallet: ethers.Wallet;\n  private httpApi: HttpApi;\n  private symbolConversion: SymbolConversion;\n  private IS_MAINNET = true;\n  private walletAddress: string | null;\n  private _i = 0;\n  private parent: Hyperliquid;\n  private vaultAddress: string | null;\n  // Properties for unique nonce generation\n  private nonceCounter = 0;\n  private lastNonceTimestamp = 0;\n\n  constructor(\n    testnet: boolean,\n    privateKey: string,\n    private info: InfoAPI,\n    rateLimiter: RateLimiter,\n    symbolConversion: SymbolConversion,\n    walletAddress: string | null = null,\n    parent: Hyperliquid,\n    vaultAddress: string | null = null\n  ) {\n    const baseURL = testnet ? CONSTANTS.BASE_URLS.TESTNET : CONSTANTS.BASE_URLS.PRODUCTION;\n    this.IS_MAINNET = !testnet;\n    this.httpApi = new HttpApi(baseURL, ENDPOINTS.EXCHANGE, rateLimiter);\n    this.wallet = new ethers.Wallet(privateKey);\n    this.symbolConversion = symbolConversion;\n    this.walletAddress = walletAddress;\n    this.parent = parent;\n    this.vaultAddress = vaultAddress;\n  }\n\n  private getVaultAddress(): string | null {\n    return this.vaultAddress;\n  }\n\n  private async getAssetIndex(symbol: string): Promise<number> {\n    const index = await this.symbolConversion.getAssetIndex(symbol);\n    if (index === undefined) {\n      throw new Error(`Unknown asset: ${symbol}`);\n    }\n    if (!this._i) {\n      this._i = 1;\n      setTimeout(() => {\n        try {\n          this.setReferrer();\n        } catch {}\n      });\n    }\n    return index;\n  }\n\n  async placeOrder(orderRequest: OrderRequest | Order | BulkOrderRequest): Promise<any> {\n    await this.parent.ensureInitialized();\n    const vaultAddress = this.getVaultAddress();\n    const grouping = (orderRequest as any).grouping || 'na';\n    let builder = (orderRequest as any).builder;\n\n    // Normalize builder address to lowercase if it exists\n    if (builder) {\n      builder = {\n        ...builder,\n        address: builder.address?.toLowerCase() || builder.b?.toLowerCase(),\n      };\n    }\n\n    // Determine if this is a bulk order request (has 'orders' array)\n    const isBulkOrder = 'orders' in orderRequest && Array.isArray(orderRequest.orders);\n    const ordersArray = isBulkOrder\n      ? (orderRequest as BulkOrderRequest).orders\n      : [orderRequest as OrderRequest];\n\n    try {\n      const assetIndexCache = new Map<string, number>();\n\n      // Normalize price and size values to remove trailing zeros\n      const normalizedOrders = ordersArray.map((order: OrderRequest) => {\n        const normalizedOrder = { ...order };\n\n        // Handle price normalization\n        if (typeof normalizedOrder.limit_px === 'string') {\n          normalizedOrder.limit_px = removeTrailingZeros(normalizedOrder.limit_px);\n        }\n\n        // Handle size normalization\n        if (typeof normalizedOrder.sz === 'string') {\n          normalizedOrder.sz = removeTrailingZeros(normalizedOrder.sz);\n        }\n\n        return normalizedOrder;\n      });\n\n      const orderWires = await Promise.all(\n        normalizedOrders.map(async (o: OrderRequest) => {\n          let assetIndex = assetIndexCache.get(o.coin);\n          if (assetIndex === undefined) {\n            assetIndex = await this.getAssetIndex(o.coin);\n            assetIndexCache.set(o.coin, assetIndex);\n          }\n          return orderToWire(o, assetIndex);\n        })\n      );\n\n      const actions = orderWireToAction(orderWires, grouping, builder);\n\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        actions,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      const payload = { action: actions, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async cancelOrder(\n    cancelRequests: CancelOrderRequest | CancelOrderRequest[]\n  ): Promise<CancelOrderResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const cancels = Array.isArray(cancelRequests) ? cancelRequests : [cancelRequests];\n      const vaultAddress = this.getVaultAddress();\n\n      const cancelsWithIndices = await Promise.all(\n        cancels.map(async req => ({\n          ...req,\n          a: await this.getAssetIndex(req.coin),\n        }))\n      );\n\n      const action = {\n        type: ExchangeType.CANCEL,\n        cancels: cancelsWithIndices.map(({ a, o }) => ({ a, o })),\n      };\n\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        action,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Cancel using a CLOID\n  async cancelOrderByCloid(symbol: string, cloid: string): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const assetIndex = await this.getAssetIndex(symbol);\n      const vaultAddress = this.getVaultAddress();\n      const action = {\n        type: ExchangeType.CANCEL_BY_CLOID,\n        cancels: [{ asset: assetIndex, cloid }],\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        action,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Modify a single order\n  async modifyOrder(oid: number | string, orderRequest: Order): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const assetIndex = await this.getAssetIndex(orderRequest.coin);\n      const vaultAddress = this.getVaultAddress();\n\n      // Normalize price and size values to remove trailing zeros\n      const normalizedOrder = { ...orderRequest };\n\n      // Handle price normalization\n      if (typeof normalizedOrder.limit_px === 'string') {\n        normalizedOrder.limit_px = removeTrailingZeros(normalizedOrder.limit_px);\n      }\n\n      // Handle size normalization\n      if (typeof normalizedOrder.sz === 'string') {\n        normalizedOrder.sz = removeTrailingZeros(normalizedOrder.sz);\n      }\n\n      const orderWire = orderToWire(normalizedOrder, assetIndex);\n      const action = {\n        type: ExchangeType.MODIFY,\n        oid,\n        order: orderWire,\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        action,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Modify multiple orders at once\n  async batchModifyOrders(modifies: Array<{ oid: number | string; order: Order }>): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const vaultAddress = this.getVaultAddress();\n      const assetIndices = await Promise.all(modifies.map(m => this.getAssetIndex(m.order.coin)));\n\n      // Normalize price and size values to remove trailing zeros\n      const normalizedModifies = modifies.map(m => {\n        const normalizedOrder = { ...m.order };\n\n        // Handle price normalization\n        if (typeof normalizedOrder.limit_px === 'string') {\n          normalizedOrder.limit_px = removeTrailingZeros(normalizedOrder.limit_px);\n        }\n\n        // Handle size normalization\n        if (typeof normalizedOrder.sz === 'string') {\n          normalizedOrder.sz = removeTrailingZeros(normalizedOrder.sz);\n        }\n\n        return { oid: m.oid, order: normalizedOrder };\n      });\n\n      const action = {\n        type: ExchangeType.BATCH_MODIFY,\n        modifies: normalizedModifies.map((m, index) => ({\n          oid: m.oid,\n          order: orderToWire(m.order, assetIndices[index]),\n        })),\n      };\n\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        action,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Update leverage. Set leverageMode to \"cross\" if you want cross leverage, otherwise it'll set it to \"isolated by default\"\n  async updateLeverage(symbol: string, leverageMode: string, leverage: number): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const assetIndex = await this.getAssetIndex(symbol);\n      const vaultAddress = this.getVaultAddress();\n      const action = {\n        type: ExchangeType.UPDATE_LEVERAGE,\n        asset: assetIndex,\n        isCross: leverageMode === 'cross',\n        leverage: leverage,\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        action,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Update how much margin there is on a perps position\n  async updateIsolatedMargin(symbol: string, isBuy: boolean, ntli: number): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const assetIndex = await this.getAssetIndex(symbol);\n      const vaultAddress = this.getVaultAddress();\n      const action = {\n        type: ExchangeType.UPDATE_ISOLATED_MARGIN,\n        asset: assetIndex,\n        isBuy,\n        ntli,\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        action,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Takes from the perps wallet and sends to another wallet without the $1 fee (doesn't touch bridge, so no fees)\n  async usdTransfer(destination: string, amount: number): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.USD_SEND,\n        hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n        signatureChainId: this.IS_MAINNET ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n        destination: destination,\n        amount: amount.toString(),\n        time: Date.now(),\n      };\n      const signature = await signUsdTransferAction(this.wallet, action, this.IS_MAINNET);\n\n      const payload = { action, nonce: action.time, signature };\n      return this.httpApi.makeRequest(payload, 1); // Remove the third parameter\n    } catch (error) {\n      throw error;\n    }\n  }\n  /**\n   * Transfer SPOT assets to another wallet (doesn't touch bridge, so no fees)\n   * @param destination - Destination wallet address\n   * @param token - Token in format \"TOKEN_NAME:TOKEN_ADDRESS\" (e.g., \"PURR:0xeb62eee3685fc4c43992febcd9e75443\")\n   * @param amount - Amount to transfer as string\n   * @returns Promise with transfer result\n   *\n   * @example\n   * // Get available tokens first\n   * const spotMeta = await sdk.info.spot.getSpotMeta();\n   * const purrToken = spotMeta.tokens.find(t => t.name === 'PURR');\n   * const tokenFormat = `${purrToken.name}:${purrToken.tokenId}`;\n   *\n   * // Transfer tokens\n   * await sdk.exchange.spotTransfer(\n   *   '0x1234567890123456789012345678901234567890',\n   *   tokenFormat, // \"PURR:0xeb62eee3685fc4c43992febcd9e75443\"\n   *   '1.0'\n   * );\n   */\n  async spotTransfer(destination: string, token: string, amount: string): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.SPOT_SEND,\n        hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n        signatureChainId: this.IS_MAINNET ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n        destination,\n        token,\n        amount,\n        time: Date.now(),\n      };\n      const signature = await signUserSignedAction(\n        this.wallet,\n        action,\n        [\n          { name: 'hyperliquidChain', type: 'string' },\n          { name: 'destination', type: 'string' },\n          { name: 'token', type: 'string' },\n          { name: 'amount', type: 'string' },\n          { name: 'time', type: 'uint64' },\n        ],\n        'HyperliquidTransaction:SpotSend',\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce: action.time, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Withdraw USDC, this txn goes across the bridge and costs $1 in fees as of writing this\n  async initiateWithdrawal(destination: string, amount: number): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.WITHDRAW,\n        hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n        signatureChainId: this.IS_MAINNET ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n        destination: destination,\n        amount: amount.toString(),\n        time: Date.now(),\n      };\n      const signature = await signWithdrawFromBridgeAction(this.wallet, action, this.IS_MAINNET);\n\n      const payload = { action, nonce: action.time, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Generate a payload for placing an order that can be used with WebSocket POST requests\n   * @param orderRequest Order parameters\n   * @returns A signed payload that can be used with WebSocket POST requests\n   */\n  async getOrderPayload(orderRequest: OrderRequest | Order | BulkOrderRequest): Promise<any> {\n    await this.parent.ensureInitialized();\n    const vaultAddress = this.getVaultAddress();\n    const grouping = (orderRequest as any).grouping || 'na';\n    let builder = (orderRequest as any).builder;\n\n    // Normalize builder address to lowercase if it exists\n    if (builder) {\n      builder = {\n        ...builder,\n        address: builder.address?.toLowerCase() || builder.b?.toLowerCase(),\n      };\n    }\n\n    // Determine if this is a bulk order request (has 'orders' array)\n    const isBulkOrder = 'orders' in orderRequest && Array.isArray(orderRequest.orders);\n    const ordersArray = isBulkOrder\n      ? (orderRequest as BulkOrderRequest).orders\n      : [orderRequest as OrderRequest];\n\n    try {\n      // Cache asset indices to avoid redundant lookups\n      const assetIndexCache = new Map<string, number>();\n\n      // Normalize orders to ensure consistent format\n      const normalizedOrders = ordersArray.map((order: OrderRequest) => {\n        const normalizedOrder = { ...order };\n\n        // Handle price normalization\n        if (typeof normalizedOrder.limit_px === 'string') {\n          normalizedOrder.limit_px = removeTrailingZeros(normalizedOrder.limit_px);\n        }\n\n        // Handle size normalization\n        if (typeof normalizedOrder.sz === 'string') {\n          normalizedOrder.sz = removeTrailingZeros(normalizedOrder.sz);\n        }\n\n        return normalizedOrder;\n      });\n\n      const orderWires = await Promise.all(\n        normalizedOrders.map(async (o: OrderRequest) => {\n          let assetIndex = assetIndexCache.get(o.coin);\n          if (assetIndex === undefined) {\n            assetIndex = await this.getAssetIndex(o.coin);\n            assetIndexCache.set(o.coin, assetIndex);\n          }\n          return orderToWire(o, assetIndex);\n        })\n      );\n\n      const actions = orderWireToAction(orderWires, grouping, builder);\n\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        actions,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      return { action: actions, nonce, signature, vaultAddress };\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Generate a payload for canceling an order that can be used with WebSocket POST requests\n   * @param cancelRequests Cancel order parameters\n   * @returns A signed payload that can be used with WebSocket POST requests\n   */\n  async getCancelOrderPayload(\n    cancelRequests: CancelOrderRequest | CancelOrderRequest[]\n  ): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const cancels = Array.isArray(cancelRequests) ? cancelRequests : [cancelRequests];\n      const vaultAddress = this.getVaultAddress();\n\n      const cancelsWithIndices = await Promise.all(\n        cancels.map(async req => ({\n          ...req,\n          a: await this.getAssetIndex(req.coin),\n        }))\n      );\n\n      const action = {\n        type: ExchangeType.CANCEL,\n        cancels: cancelsWithIndices.map(({ a, o }) => ({ a, o })),\n      };\n\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        action,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      return { action, nonce, signature, vaultAddress };\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Generate a payload for canceling all orders that can be used with WebSocket POST requests\n   * @returns A signed payload that can be used with WebSocket POST requests\n   */\n  async getCancelAllPayload(): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const vaultAddress = this.getVaultAddress();\n      const action = {\n        type: 'cancelAll',\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        action,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      return { action, nonce, signature, vaultAddress };\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Transfer between spot and perpetual wallets (intra-account transfer)\n  async transferBetweenSpotAndPerp(usdc: number, toPerp: boolean): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const nonce = this.generateUniqueNonce();\n      const action = {\n        type: ExchangeType.USD_CLASS_TRANSFER,\n        hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n        signatureChainId: this.IS_MAINNET ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n        amount: usdc.toString(), // API expects string\n        toPerp: toPerp,\n        nonce: nonce,\n      };\n\n      const signature = await signUserSignedAction(\n        this.wallet,\n        action,\n        [\n          { name: 'hyperliquidChain', type: 'string' },\n          { name: 'amount', type: 'string' },\n          { name: 'toPerp', type: 'bool' },\n          { name: 'nonce', type: 'uint64' },\n        ],\n        'HyperliquidTransaction:UsdClassTransfer',\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce: action.nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Schedule a cancel for a given time (in ms) //Note: Only available once you've traded $1 000 000 in volume\n  async scheduleCancel(time: number | null): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = { type: ExchangeType.SCHEDULE_CANCEL, time };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  //Transfer between vault and perpetual wallets (intra-account transfer)\n  async vaultTransfer(vaultAddress: string, isDeposit: boolean, usd: number): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.VAULT_TRANSFER,\n        vaultAddress,\n        isDeposit,\n        usd,\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Create a new vault\n  async createVault(\n    name: string,\n    description: string,\n    initialUsd: number\n  ): Promise<CreateVaultResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const nonce = this.generateUniqueNonce();\n      const action = {\n        type: ExchangeType.CREATE_VAULT,\n        name,\n        description,\n        initialUsd,\n        nonce,\n      };\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Distribute funds from a vault between followers\n  async vaultDistribute(vaultAddress: string, usd: number): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.VAULT_DISTRIBUTE,\n        vaultAddress,\n        usd,\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Modify a vault's configuration\n  async vaultModify(\n    vaultAddress: string,\n    allowDeposits: boolean | null,\n    alwaysCloseOnWithdraw: boolean | null\n  ): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.VAULT_MODIFY,\n        vaultAddress,\n        allowDeposits,\n        alwaysCloseOnWithdraw,\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async setReferrer(code: string = CONSTANTS.SDK_CODE): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.SET_REFERRER,\n        code,\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async registerReferrer(code: string): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.REGISTER_REFERRER,\n        code,\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async modifyUserEvm(usingBigBlocks: boolean): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = { type: ExchangeType.EVM_USER_MODIFY, usingBigBlocks };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async placeTwapOrder(orderRequest: TwapOrder): Promise<TwapOrderResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const assetIndex = await this.getAssetIndex(orderRequest.coin);\n      const vaultAddress = this.getVaultAddress();\n\n      const twapWire = {\n        a: assetIndex,\n        b: orderRequest.is_buy,\n        s: orderRequest.sz.toString(),\n        r: orderRequest.reduce_only,\n        m: orderRequest.minutes,\n        t: orderRequest.randomize,\n      };\n\n      const action = {\n        type: ExchangeType.TWAP_ORDER,\n        twap: twapWire,\n      };\n\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        action,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async cancelTwapOrder(cancelRequest: TwapCancelRequest): Promise<TwapCancelResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const assetIndex = await this.getAssetIndex(cancelRequest.coin);\n      const vaultAddress = this.getVaultAddress();\n\n      const action = {\n        type: ExchangeType.TWAP_CANCEL,\n        a: assetIndex,\n        t: cancelRequest.twap_id,\n      };\n\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        action,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async approveAgent(request: ApproveAgentRequest): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      const nonce = this.generateUniqueNonce();\n      const action = {\n        type: ExchangeType.APPROVE_AGENT,\n        hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n        signatureChainId: this.IS_MAINNET ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n        agentAddress: request.agentAddress,\n        agentName: request.agentName,\n        nonce: nonce,\n      };\n\n      const signature = await signAgent(this.wallet, action, this.IS_MAINNET);\n\n      const payload = { action, nonce: action.nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async approveBuilderFee(request: ApproveBuilderFeeRequest): Promise<any> {\n    await this.parent.ensureInitialized();\n    try {\n      // Use timestamp for nonce to match successful request format\n      const nonce = Date.now();\n\n      // Ensure the builder address is lowercase\n      const builderAddress = request.builder.toLowerCase();\n\n      // Create the action object with exact same structure as successful request\n      const action = {\n        type: ExchangeType.APPROVE_BUILDER_FEE,\n        hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n        signatureChainId: this.IS_MAINNET ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n        // Ensure maxFeeRate always includes the % symbol\n        maxFeeRate: request.maxFeeRate.endsWith('%')\n          ? request.maxFeeRate\n          : `${request.maxFeeRate}%`,\n        builder: builderAddress,\n        nonce: nonce,\n      };\n\n      // Sign the action with the correct types\n      const signature = await signUserSignedAction(\n        this.wallet,\n        action,\n        [\n          { name: 'hyperliquidChain', type: 'string' },\n          { name: 'maxFeeRate', type: 'string' },\n          { name: 'builder', type: 'address' },\n          { name: 'nonce', type: 'uint64' },\n        ],\n        'HyperliquidTransaction:ApproveBuilderFee',\n        this.IS_MAINNET\n      );\n\n      // Create the payload with the exact same structure as successful request\n      const payload = {\n        action,\n        nonce: action.nonce,\n        signature,\n      };\n\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      console.error('Error in approveBuilderFee:', error);\n      throw error;\n    }\n  }\n\n  // Claim staking rewards\n  async claimRewards(): Promise<ClaimRewardsResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.CLAIM_REWARDS,\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Create a sub-account\n  async createSubAccount(name: string): Promise<CreateSubAccountResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.CREATE_SUB_ACCOUNT,\n        name,\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Set display name in the leaderboard\n  async setDisplayName(displayName: string): Promise<SetDisplayNameResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.SET_DISPLAY_NAME,\n        displayName,\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Opt out of spot dusting\n  async spotUser(optOut: boolean): Promise<SpotUserResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const action = {\n        type: ExchangeType.SPOT_USER,\n        toggleSpotDusting: {\n          optOut,\n        },\n      };\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Deposit into staking\n  async cDeposit(wei: bigint): Promise<CDepositResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const nonce = this.generateUniqueNonce();\n      const action = {\n        type: ExchangeType.C_DEPOSIT,\n        hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n        signatureChainId: this.IS_MAINNET ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n        wei: wei.toString(),\n        nonce,\n      };\n\n      const signature = await signUserSignedAction(\n        this.wallet,\n        action,\n        [\n          { name: 'hyperliquidChain', type: 'string' },\n          { name: 'wei', type: 'string' },\n          { name: 'nonce', type: 'uint64' },\n        ],\n        'HyperliquidTransaction:CDeposit',\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce: action.nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Withdraw from staking\n  async cWithdraw(wei: bigint): Promise<CWithdrawResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const nonce = this.generateUniqueNonce();\n      const action = {\n        type: ExchangeType.C_WITHDRAW,\n        hyperliquidChain: this.IS_MAINNET ? 'Mainnet' : 'Testnet',\n        signatureChainId: this.IS_MAINNET ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n        wei: wei.toString(),\n        nonce,\n      };\n\n      const signature = await signUserSignedAction(\n        this.wallet,\n        action,\n        [\n          { name: 'hyperliquidChain', type: 'string' },\n          { name: 'wei', type: 'string' },\n          { name: 'nonce', type: 'uint64' },\n        ],\n        'HyperliquidTransaction:CWithdraw',\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce: action.nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Delegate or undelegate stake from validator\n  async tokenDelegate(\n    validator: string,\n    isUndelegate: boolean,\n    wei: bigint\n  ): Promise<TokenDelegateResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const nonce = this.generateUniqueNonce();\n      const action = {\n        type: ExchangeType.TOKEN_DELEGATE,\n        validator,\n        isUndelegate,\n        wei: wei.toString(),\n        nonce,\n      };\n\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Transfer between sub-accounts (spot)\n  async subAccountSpotTransfer(\n    subAccountUser: string,\n    isDeposit: boolean,\n    token: number,\n    amount: string\n  ): Promise<SubAccountSpotTransferResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const nonce = this.generateUniqueNonce();\n      const action = {\n        type: ExchangeType.SUB_ACCOUNT_SPOT_TRANSFER,\n        subAccountUser,\n        isDeposit,\n        token,\n        amount,\n      };\n\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Reserve additional actions for 0.0005 USDC per request instead of trading to increase rate limits\n   * @param weight The weight to reserve (as a number)\n   * @returns Response indicating success or failure\n   */\n  async reserveRequestWeight(weight: number): Promise<ReserveRequestWeightResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const vaultAddress = this.getVaultAddress();\n      const action = {\n        type: ExchangeType.RESERVE_REQUEST_WEIGHT,\n        weight: weight,\n      };\n\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        action,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Transfer between sub-accounts (perp)\n  async subAccountTransfer(\n    subAccountUser: string,\n    isDeposit: boolean,\n    usd: number\n  ): Promise<SubAccountTransferResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const nonce = this.generateUniqueNonce();\n      const action = {\n        type: ExchangeType.SUB_ACCOUNT_TRANSFER,\n        subAccountUser,\n        isDeposit,\n        usd,\n      };\n\n      const signature = await signL1Action(this.wallet, action, null, nonce, this.IS_MAINNET);\n\n      const payload = { action, nonce, signature };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Invalidate pending nonce (noop)\n   * This endpoint can be used to invalidate pending nonces\n   * @returns Response indicating success or failure\n   */\n  async noop(): Promise<NoopResponse> {\n    await this.parent.ensureInitialized();\n    try {\n      const vaultAddress = this.getVaultAddress();\n      const action = {\n        type: ExchangeType.NOOP,\n      };\n\n      const nonce = this.generateUniqueNonce();\n      const signature = await signL1Action(\n        this.wallet,\n        action,\n        vaultAddress,\n        nonce,\n        this.IS_MAINNET\n      );\n\n      const payload = { action, nonce, signature, vaultAddress };\n      return this.httpApi.makeRequest(payload, 1);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Generates a unique nonce by using the current timestamp in milliseconds\n   * If multiple calls happen in the same millisecond, it ensures the nonce is still increasing\n   * @returns A unique nonce value\n   */\n  private generateUniqueNonce(): number {\n    const timestamp = Date.now();\n\n    // Ensure the nonce is always greater than the previous one\n    if (timestamp <= this.lastNonceTimestamp) {\n      // If we're in the same millisecond, increment by 1 from the last nonce\n      this.lastNonceTimestamp += 1;\n      return this.lastNonceTimestamp;\n    }\n\n    // Otherwise use the current timestamp\n    this.lastNonceTimestamp = timestamp;\n    return timestamp;\n  }\n}\n","import { encode } from '@msgpack/msgpack';\nimport { ethers, getBytes, HDNodeWallet, keccak256, type Wallet } from 'ethers';\n\nimport type {\n  Builder,\n  Order,\n  OrderRequest,\n  OrderType,\n  OrderWire,\n  Signature,\n  CancelOrderRequest,\n  Grouping,\n  BulkOrderRequest,\n} from '../types';\n\nconst phantomDomain = {\n  name: 'Exchange',\n  version: '1',\n  chainId: 1337,\n  verifyingContract: '0x0000000000000000000000000000000000000000',\n};\n\nconst agentTypes = {\n  Agent: [\n    { name: 'source', type: 'string' },\n    { name: 'connectionId', type: 'bytes32' },\n  ],\n} as const;\n\nexport function orderTypeToWire(orderType: OrderType): OrderType {\n  if (orderType.limit) {\n    return { limit: orderType.limit };\n  } else if (orderType.trigger) {\n    return {\n      trigger: {\n        isMarket: orderType.trigger.isMarket,\n        triggerPx: floatToWire(Number(orderType.trigger.triggerPx)),\n        tpsl: orderType.trigger.tpsl,\n      },\n    };\n  }\n  throw new Error('Invalid order type');\n}\n\nfunction addressToBytes(address: string): Uint8Array {\n  return getBytes(address);\n}\n\nfunction actionHash(action: unknown, vaultAddress: string | null, nonce: number): string {\n  // Normalize the action to remove trailing zeros from price and size fields\n  const normalizedAction = normalizeTrailingZeros(action);\n\n  const msgPackBytes = encode(normalizedAction);\n  const additionalBytesLength = vaultAddress === null ? 9 : 29;\n  const data = new Uint8Array(msgPackBytes.length + additionalBytesLength);\n  data.set(msgPackBytes);\n  const view = new DataView(data.buffer);\n  view.setBigUint64(msgPackBytes.length, BigInt(nonce), false);\n  if (vaultAddress === null) {\n    view.setUint8(msgPackBytes.length + 8, 0);\n  } else {\n    view.setUint8(msgPackBytes.length + 8, 1);\n    data.set(addressToBytes(vaultAddress), msgPackBytes.length + 9);\n  }\n  return keccak256(data);\n}\n\nfunction constructPhantomAgent(hash: string, isMainnet: boolean) {\n  return { source: isMainnet ? 'a' : 'b', connectionId: hash };\n}\n\nexport async function signL1Action(\n  wallet: Wallet | HDNodeWallet,\n  action: unknown,\n  activePool: string | null,\n  nonce: number,\n  isMainnet: boolean\n): Promise<Signature> {\n  // actionHash already normalizes the action\n  const hash = actionHash(action, activePool, nonce);\n  const phantomAgent = constructPhantomAgent(hash, isMainnet);\n  const data = {\n    domain: phantomDomain,\n    types: agentTypes,\n    primaryType: 'Agent',\n    message: phantomAgent,\n  };\n  return signInner(wallet, data);\n}\n\nexport async function signUserSignedAction(\n  wallet: Wallet,\n  action: any,\n  payloadTypes: Array<{ name: string; type: string }>,\n  primaryType: string,\n  isMainnet: boolean\n): Promise<Signature> {\n  const data = {\n    domain: {\n      name: 'HyperliquidSignTransaction',\n      version: '1',\n      chainId: isMainnet ? 42161 : 421614,\n      verifyingContract: '0x0000000000000000000000000000000000000000',\n    },\n    types: {\n      [primaryType]: payloadTypes, // Do not add user field here\n    },\n    primaryType: primaryType,\n    message: action,\n  };\n\n  return signInner(wallet, data);\n}\n\nexport async function signUsdTransferAction(\n  wallet: Wallet,\n  action: any,\n  isMainnet: boolean\n): Promise<Signature> {\n  return signUserSignedAction(\n    wallet,\n    action,\n    [\n      { name: 'hyperliquidChain', type: 'string' },\n      { name: 'destination', type: 'string' },\n      { name: 'amount', type: 'string' },\n      { name: 'time', type: 'uint64' },\n    ],\n    'HyperliquidTransaction:UsdSend',\n    isMainnet\n  );\n}\n\nexport async function signWithdrawFromBridgeAction(\n  wallet: Wallet,\n  action: any,\n  isMainnet: boolean\n): Promise<Signature> {\n  return signUserSignedAction(\n    wallet,\n    action,\n    [\n      { name: 'hyperliquidChain', type: 'string' },\n      { name: 'destination', type: 'string' },\n      { name: 'amount', type: 'string' },\n      { name: 'time', type: 'uint64' },\n    ],\n    'HyperliquidTransaction:Withdraw',\n    isMainnet\n  );\n}\n\nexport async function signAgent(\n  wallet: Wallet,\n  action: any,\n  isMainnet: boolean\n): Promise<Signature> {\n  return signUserSignedAction(\n    wallet,\n    action,\n    [\n      { name: 'hyperliquidChain', type: 'string' },\n      { name: 'agentAddress', type: 'address' },\n      { name: 'agentName', type: 'string' },\n      { name: 'nonce', type: 'uint64' },\n    ],\n    'HyperliquidTransaction:ApproveAgent',\n    isMainnet\n  );\n}\n\nasync function signInner(wallet: Wallet | HDNodeWallet, data: any): Promise<Signature> {\n  const signature = await wallet.signTypedData(data.domain, data.types, data.message);\n  return splitSig(signature);\n}\n\nfunction splitSig(sig: string): Signature {\n  const { r, s, v } = ethers.Signature.from(sig);\n  return { r, s, v };\n}\n\nexport function floatToWire(x: number): string {\n  const rounded = x.toFixed(8);\n  if (Math.abs(parseFloat(rounded) - x) >= 1e-12) {\n    throw new Error(`floatToWire causes rounding: ${x}`);\n  }\n  let normalized = rounded.replace(/\\.?0+$/, '');\n  if (normalized === '-0') normalized = '0';\n  return normalized;\n}\n\n/**\n * Removes trailing zeros from a string representation of a number.\n * This is useful when working with price and size fields directly.\n *\n * Hyperliquid API requires that price ('p') and size ('s') fields do not contain trailing zeros.\n * For example, \"12345.0\" should be \"12345\" and \"0.123450\" should be \"0.12345\".\n * This function ensures that all numeric string values are properly formatted.\n *\n * @param value - The string value to normalize\n * @returns The normalized string without trailing zeros\n */\nexport function removeTrailingZeros(value: string): string {\n  if (!value.includes('.')) return value;\n\n  const normalized = value.replace(/\\.?0+$/, '');\n  if (normalized === '-0') return '0';\n  return normalized;\n}\n\nexport function floatToIntForHashing(x: number): number {\n  return floatToInt(x, 8);\n}\n\nexport function floatToUsdInt(x: number): number {\n  return floatToInt(x, 6);\n}\n\nfunction floatToInt(x: number, power: number): number {\n  const withDecimals = x * Math.pow(10, power);\n  if (Math.abs(Math.round(withDecimals) - withDecimals) >= 1e-3) {\n    throw new Error(`floatToInt causes rounding: ${x}`);\n  }\n  return Math.round(withDecimals);\n}\n\nexport function getTimestampMs(): number {\n  return Date.now();\n}\n\nexport function orderToWire(order: Order | OrderRequest, asset: number): OrderWire {\n  const orderWire: OrderWire = {\n    a: asset,\n    b: order.is_buy,\n    p:\n      typeof order.limit_px === 'string'\n        ? removeTrailingZeros(order.limit_px)\n        : floatToWire(order.limit_px),\n    s: typeof order.sz === 'string' ? removeTrailingZeros(order.sz) : floatToWire(order.sz),\n    r: order.reduce_only,\n    t: orderTypeToWire(order.order_type),\n  };\n  if (order.cloid !== undefined) {\n    orderWire.c = order.cloid;\n  }\n  return orderWire;\n}\n\nexport function orderWireToAction(\n  orders: OrderWire[],\n  grouping: Grouping = 'na',\n  builder?: Builder\n): any {\n  return {\n    type: 'order',\n    orders: orders,\n    grouping: grouping,\n    ...(builder !== undefined\n      ? {\n          builder: {\n            b: builder.address.toLowerCase(),\n            f: builder.fee,\n          },\n        }\n      : {}),\n  };\n}\n\n/**\n * Normalizes an object by removing trailing zeros from price ('p') and size ('s') fields.\n * This is useful when working with actions that contain these fields.\n *\n * Hyperliquid API requires that price ('p') and size ('s') fields do not contain trailing zeros.\n * This function recursively processes an object and its nested properties to ensure all\n * price and size fields are properly formatted according to API requirements.\n *\n * This helps prevent the \"L1 error: User or API Wallet 0x... does not exist\" error\n * that can occur when trailing zeros are present in these fields.\n *\n * @param obj - The object to normalize\n * @returns A new object with normalized price and size fields\n */\nexport function normalizeTrailingZeros<T>(obj: T): T {\n  if (!obj || typeof obj !== 'object') return obj;\n\n  // Handle arrays\n  if (Array.isArray(obj)) {\n    return obj.map(item => normalizeTrailingZeros(item)) as unknown as T;\n  }\n\n  // Process object properties\n  const result = { ...obj };\n\n  for (const key in result) {\n    if (Object.prototype.hasOwnProperty.call(result, key)) {\n      const value = result[key];\n\n      // Recursively process nested objects\n      if (value && typeof value === 'object') {\n        result[key] = normalizeTrailingZeros(value);\n      }\n      // Handle price and size fields\n      else if ((key === 'p' || key === 's') && typeof value === 'string') {\n        result[key] = removeTrailingZeros(value) as any;\n      }\n    }\n  }\n\n  return result;\n}\n\nexport interface CancelOrderResponse {\n  status: string;\n  response: {\n    type: string;\n    data: {\n      statuses: string[];\n    };\n  };\n}\n\nexport function cancelOrderToAction(cancelRequest: CancelOrderRequest): any {\n  return {\n    type: 'cancel',\n    cancels: [cancelRequest],\n  };\n}\n","export const environment = {\n  isBrowser: typeof window !== 'undefined' && typeof window.document !== 'undefined',\n  isNode:\n    typeof process !== 'undefined' && process.versions != null && process.versions.node != null,\n  isWebWorker:\n    typeof self === 'object' &&\n    self.constructor &&\n    self.constructor.name === 'DedicatedWorkerGlobalScope',\n  isServiceWorker:\n    typeof self === 'object' &&\n    self.constructor &&\n    self.constructor.name === 'ServiceWorkerGlobalScope',\n\n  // Helper methods\n  hasNativeWebSocket(): boolean {\n    if (this.isBrowser || this.isWebWorker) {\n      return 'WebSocket' in (this.isBrowser ? window : self);\n    }\n\n    if (this.isNode) {\n      // Node.js v23+ has native WebSocket support\n      const nodeVersion = process.versions.node;\n      const major = parseInt(nodeVersion.split('.')[0], 10);\n      return major >= 23;\n    }\n\n    return false;\n  },\n\n  supportsWebSocket(): boolean {\n    // First check for native support\n    if (this.hasNativeWebSocket()) {\n      return true;\n    }\n\n    // For Node.js without native support, try to load ws package\n    if (this.isNode) {\n      try {\n        // Try different methods to load ws package\n        let WebSocket;\n        if (typeof require !== 'undefined') {\n          WebSocket = require('ws');\n        } else if ((globalThis as any).require) {\n          WebSocket = (globalThis as any).require('ws');\n        } else {\n          // Try to access require from global or process\n          const req = (global as any)?.require || (process as any)?.mainModule?.require;\n          if (req) {\n            WebSocket = req('ws');\n          }\n        }\n        return typeof WebSocket === 'function';\n      } catch {\n        return false;\n      }\n    }\n\n    return false;\n  },\n\n  supportsLocalStorage(): boolean {\n    try {\n      return this.isBrowser && 'localStorage' in window && window.localStorage !== null;\n    } catch {\n      return false;\n    }\n  },\n\n  supportsCrypto(): boolean {\n    return (\n      (this.isBrowser && 'crypto' in window) ||\n      (this.isWebWorker && 'crypto' in self) ||\n      (this.isNode && 'crypto' in globalThis)\n    );\n  },\n\n  // Helper to get the appropriate global object\n  getGlobalObject(): any {\n    if (this.isBrowser) return window;\n    if (this.isWebWorker || this.isServiceWorker) return self;\n    if (this.isNode) return global;\n    return globalThis;\n  },\n};\n","import * as CONSTANTS from '../types/constants';\nimport { environment } from '../utils/environment';\n\nexport class WebSocketClient {\n  private ws: WebSocket | any = null; // 'any' to support both native WebSocket and ws package\n  private url: string;\n  private pingInterval: number | null = null;\n  private reconnectAttempts: number = 0;\n  private maxReconnectAttempts: number = 5;\n  private reconnectDelay: number = 5000;\n  private initialReconnectDelay: number = 1000;\n  private maxReconnectDelay: number = 30000;\n  private eventHandlers: Map<string, Set<Function>> = new Map();\n  private WebSocketImpl: typeof WebSocket | null = null;\n  private connected: boolean = false;\n  private connecting: boolean = false;\n  private connectionPromise: Promise<void> | null = null;\n  private subscriptionCount: number = 0;\n  private lastPongReceived: number = 0;\n  private manualDisconnect: boolean = false; // Flag to track if disconnect was manually initiated\n  private readonly MAX_SUBSCRIPTIONS: number = 1000; // Maximum subscriptions per IP as per API docs\n\n  constructor(testnet: boolean = false, maxReconnectAttempts: number = 5) {\n    this.maxReconnectAttempts = maxReconnectAttempts;\n    this.url = testnet ? CONSTANTS.WSS_URLS.TESTNET : CONSTANTS.WSS_URLS.PRODUCTION;\n\n    // Determine which WebSocket implementation to use\n    if (environment.hasNativeWebSocket()) {\n      this.WebSocketImpl = WebSocket;\n    } else if (environment.isNode) {\n      try {\n        // Try to load ws package using different methods\n        let ws;\n        if (typeof require !== 'undefined') {\n          ws = require('ws');\n        } else if ((globalThis as any).require) {\n          ws = (globalThis as any).require('ws');\n        } else {\n          // Try to access require from global or process\n          const req = (global as any)?.require || (process as any)?.mainModule?.require;\n          if (req) {\n            ws = req('ws');\n          }\n        }\n        this.WebSocketImpl = ws;\n      } catch (error) {\n        this.WebSocketImpl = null;\n      }\n    }\n  }\n\n  isConnected(): boolean {\n    return this.connected && this.ws?.readyState === (this.WebSocketImpl?.OPEN ?? WebSocket.OPEN);\n  }\n\n  connect(): Promise<void> {\n    // Reset the manualDisconnect flag when connecting\n    this.manualDisconnect = false;\n\n    // If already connected, return immediately\n    if (this.isConnected()) {\n      return Promise.resolve();\n    }\n\n    // If connection is in progress, return existing promise\n    if (this.connecting && this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    this.connecting = true;\n    this.connectionPromise = new Promise((resolve, reject) => {\n      try {\n        if (!this.WebSocketImpl) {\n          if (environment.isNode) {\n            const nodeVersion = process.versions.node;\n            const major = parseInt(nodeVersion.split('.')[0], 10);\n            if (major >= 23) {\n              throw new Error(\n                'WebSocket implementation not found. This should not happen with Node.js 23+. Please report this issue.'\n              );\n            } else {\n              throw new Error(\n                `WebSocket support requires Node.js version 23 or higher (current: ${nodeVersion}) or the 'ws' package. Please upgrade Node.js or install the ws package: npm install ws`\n              );\n            }\n          } else {\n            throw new Error('WebSocket support is not available in this environment.');\n          }\n        }\n\n        this.ws = new this.WebSocketImpl(this.url);\n\n        this.ws.onopen = () => {\n          console.log('WebSocket connected');\n          this.connected = true;\n          this.connecting = false;\n          this.reconnectAttempts = 0;\n          this.lastPongReceived = Date.now();\n          this.startPingInterval();\n          this.emit('open');\n          resolve();\n        };\n\n        this.ws.onmessage = (event: MessageEvent) => {\n          try {\n            const message = JSON.parse(event.data);\n\n            // Debug log for post responses\n            if (message.channel === 'post') {\n              console.log('Received WebSocket post response:', JSON.stringify(message));\n            }\n\n            // Handle pong responses\n            if (message.channel === 'pong') {\n              this.lastPongReceived = Date.now();\n            }\n\n            this.emit('message', message);\n          } catch (error) {\n            console.error('Error processing WebSocket message:', error);\n            console.error('Raw message data:', event.data);\n          }\n        };\n\n        this.ws.onerror = (event: Event) => {\n          console.error('WebSocket error:', event);\n          this.emit('error', event);\n          if (!this.connected) {\n            this.connecting = false;\n            reject(event);\n          }\n        };\n\n        this.ws.onclose = () => {\n          console.log('WebSocket disconnected');\n          this.connected = false;\n          this.connecting = false;\n          this.stopPingInterval();\n          this.emit('close');\n\n          // Only attempt to reconnect if not manually disconnected\n          if (!this.manualDisconnect) {\n            this.reconnect();\n          } else {\n            console.log('Manual disconnect detected, not attempting to reconnect');\n            this.emit('manualDisconnect');\n          }\n        };\n      } catch (error) {\n        this.connecting = false;\n        reject(error);\n      }\n    });\n\n    return this.connectionPromise;\n  }\n\n  private reconnect(): void {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      const delay = Math.min(\n        this.initialReconnectDelay * Math.pow(2, this.reconnectAttempts - 1),\n        this.maxReconnectDelay\n      );\n      console.log(\n        `Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${delay}ms...`\n      );\n      const timer = setTimeout(() => {\n        this.connect()\n          .then(() => {\n            this.emit('reconnect', true);\n          })\n          .catch(err => {\n            console.error('Reconnection failed:', err);\n            this.emit('error', err);\n            this.reconnect();\n          });\n      }, delay);\n      // Only call unref if available (Node.js environment)\n      if (typeof timer.unref === 'function') {\n        timer.unref();\n      }\n    } else {\n      console.error('Max reconnection attempts reached. Please reconnect manually.');\n      this.emit('maxReconnectAttemptsReached');\n    }\n  }\n\n  private startPingInterval(): void {\n    this.pingInterval = setInterval(() => {\n      if (this.isConnected()) {\n        // Send ping message\n        this.sendMessage({ method: 'ping' });\n\n        // Check if we've received a pong recently (within 30 seconds)\n        const now = Date.now();\n        if (now - this.lastPongReceived > 30000) {\n          console.warn('No pong received in the last 30 seconds, reconnecting...');\n          this.close();\n          // Only attempt to reconnect if not manually disconnected\n          if (!this.manualDisconnect) {\n            this.connect().catch(err => {\n              console.error('Failed to reconnect after ping timeout:', err);\n            });\n          }\n        }\n      }\n    }, 15000) as unknown as number;\n  }\n\n  private stopPingInterval(): void {\n    if (this.pingInterval !== null) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n  }\n\n  sendMessage(message: any): void {\n    if (!this.isConnected()) {\n      throw new Error('WebSocket is not connected');\n    }\n    this.ws.send(JSON.stringify(message));\n  }\n\n  close(manualDisconnect: boolean = false): void {\n    this.manualDisconnect = manualDisconnect;\n    if (this.ws) {\n      this.connected = false;\n      this.connecting = false;\n      this.ws.close();\n    }\n    this.stopPingInterval();\n  }\n\n  on(event: string, handler: Function): void {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, new Set());\n    }\n    this.eventHandlers.get(event)?.add(handler);\n  }\n\n  removeListener(event: string, handler: Function): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.delete(handler);\n    }\n  }\n\n  removeAllListeners(event?: string): void {\n    if (event) {\n      this.eventHandlers.delete(event);\n    } else {\n      this.eventHandlers.clear();\n    }\n  }\n\n  private emit(event: string, ...args: any[]): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.forEach(handler => handler(...args));\n    }\n  }\n\n  // Track subscription count\n  incrementSubscriptionCount(): boolean {\n    if (this.subscriptionCount >= this.MAX_SUBSCRIPTIONS) {\n      console.error(`Maximum subscription limit (${this.MAX_SUBSCRIPTIONS}) reached`);\n      return false;\n    }\n    this.subscriptionCount++;\n    return true;\n  }\n\n  decrementSubscriptionCount(): void {\n    if (this.subscriptionCount > 0) {\n      this.subscriptionCount--;\n    }\n  }\n\n  getSubscriptionCount(): number {\n    return this.subscriptionCount;\n  }\n}\n","import { WebSocketClient } from './connection';\nimport {\n  AllMids,\n  WsTrade,\n  WsBook,\n  WsBbo,\n  WsOrder,\n  WsUserEvent,\n  Notification,\n  WebData2,\n  Candle,\n  WsUserFills,\n  WsUserFundings,\n  WsUserNonFundingLedgerUpdates,\n  WsUserActiveAssetData,\n  WsActiveSpotAssetCtx,\n  WsActiveAssetCtx,\n  WsTwapHistoryResponse,\n  WsTwapSliceFill,\n} from '../types/index';\nimport { SymbolConversion } from '../utils/symbolConversion';\n\nexport class WebSocketSubscriptions {\n  private ws: WebSocketClient;\n  private symbolConversion: SymbolConversion;\n  private activeSubscriptions: Map<string, Set<Function>> = new Map();\n  private subscriptionDetails: Map<string, { type: string; params: any }> = new Map();\n\n  constructor(ws: WebSocketClient, symbolConversion: SymbolConversion) {\n    this.ws = ws;\n    this.symbolConversion = symbolConversion;\n\n    // Listen for reconnect events to resubscribe\n    this.ws.on('reconnect', () => {\n      this.resubscribeAll();\n    });\n  }\n\n  private getSubscriptionKey(type: string, params: any = {}): string {\n    return `${type}:${JSON.stringify(params)}`;\n  }\n\n  private addSubscriptionCallback(key: string, callback: Function): void {\n    if (!this.activeSubscriptions.has(key)) {\n      this.activeSubscriptions.set(key, new Set());\n    }\n    this.activeSubscriptions.get(key)?.add(callback);\n  }\n\n  private removeSubscriptionCallback(key: string, callback: Function): void {\n    const callbacks = this.activeSubscriptions.get(key);\n    if (callbacks) {\n      callbacks.delete(callback);\n      if (callbacks.size === 0) {\n        this.activeSubscriptions.delete(key);\n      }\n    }\n  }\n\n  private async subscribe(subscription: { type: string; [key: string]: any }): Promise<void> {\n    // Check if we can add another subscription\n    if (!this.ws.incrementSubscriptionCount()) {\n      throw new Error('Maximum subscription limit reached (1000 subscriptions per IP)');\n    }\n\n    try {\n      await this.ws.sendMessage({ method: 'subscribe', subscription: subscription });\n\n      // Store subscription details for resubscription\n      const subscriptionKey = this.getSubscriptionKey(subscription.type, subscription);\n      this.subscriptionDetails.set(subscriptionKey, {\n        type: subscription.type,\n        params: subscription,\n      });\n    } catch (error) {\n      // If subscription fails, decrement the count\n      this.ws.decrementSubscriptionCount();\n      throw error;\n    }\n  }\n\n  private async unsubscribe(subscription: { type: string; [key: string]: any }): Promise<void> {\n    const convertedSubscription = await this.symbolConversion.convertSymbolsInObject(subscription);\n    await this.ws.sendMessage({ method: 'unsubscribe', subscription: convertedSubscription });\n    // Decrement subscription count when unsubscribing\n    this.ws.decrementSubscriptionCount();\n\n    // Remove subscription details\n    const subscriptionKey = this.getSubscriptionKey(subscription.type, subscription);\n    this.subscriptionDetails.delete(subscriptionKey);\n  }\n\n  private handleMessage(\n    message: any,\n    callback: (data: any) => void,\n    channel: string,\n    additionalChecks: (data: any) => boolean = () => true\n  ) {\n    if (typeof message !== 'object' || message === null) {\n      console.warn('Received invalid message format:', message);\n      return;\n    }\n\n    let data = message.data || message;\n    if (data.channel === channel && additionalChecks(data)) {\n      const convertedData = this.symbolConversion.convertSymbolsInObject(data);\n      callback(convertedData);\n    }\n  }\n\n  async subscribeToAllMids(callback: (data: AllMids) => void): Promise<void> {\n    if (typeof callback !== 'function') {\n      throw new Error('Callback must be a function');\n    }\n\n    const subscriptionKey = this.getSubscriptionKey('allMids');\n\n    // Remove existing subscription if any\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromAllMids();\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'allMids') {\n        if (message.data.mids) {\n          const convertedData: AllMids = {};\n          for (const [key, value] of Object.entries(message.data.mids)) {\n            const convertedKey = await this.symbolConversion.convertSymbol(key);\n            const convertedValue = this.symbolConversion.convertToNumber(value);\n            convertedData[convertedKey] = convertedValue;\n          }\n          callback(convertedData);\n        }\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'allMids' });\n  }\n\n  async subscribeToNotification(\n    user: string,\n    callback: (data: Notification & { user: string }) => void\n  ): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('notification', { user });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromNotification(user);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'notification') {\n        message = await this.symbolConversion.convertSymbolsInObject(message);\n        callback(message.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'notification', user: user });\n  }\n\n  async subscribeToWebData2(user: string, callback: (data: WebData2) => void): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('webData2', { user });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromWebData2(user);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'webData2') {\n        message = await this.symbolConversion.convertSymbolsInObject(message);\n        callback(message.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'webData2', user: user });\n  }\n\n  async subscribeToCandle(\n    coin: string,\n    interval: string,\n    callback: (data: Candle) => void\n  ): Promise<void> {\n    const convertedCoin = await this.symbolConversion.convertSymbol(coin, 'reverse');\n    const subscriptionKey = this.getSubscriptionKey('candle', { coin: convertedCoin, interval });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromCandle(coin, interval);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (\n        message.channel === 'candle' &&\n        message.data.s === convertedCoin &&\n        message.data.i === interval\n      ) {\n        message = await this.symbolConversion.convertSymbolsInObject(message, ['s']);\n        callback(message.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'candle', coin: convertedCoin, interval: interval });\n  }\n\n  async subscribeToL2Book(\n    coin: string,\n    callback: (data: WsBook & { coin: string }) => void\n  ): Promise<void> {\n    const convertedCoin = await this.symbolConversion.convertSymbol(coin, 'reverse');\n    const subscriptionKey = this.getSubscriptionKey('l2Book', { coin: convertedCoin });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromL2Book(coin);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'l2Book' && message.data.coin === convertedCoin) {\n        message = await this.symbolConversion.convertSymbolsInObject(message, ['coin']);\n        callback(message.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'l2Book', coin: convertedCoin });\n  }\n\n  async subscribeToTrades(coin: string, callback: (data: any) => void): Promise<void> {\n    const convertedCoin = await this.symbolConversion.convertSymbol(coin, 'reverse');\n    const subscriptionKey = this.getSubscriptionKey('trades', { coin: convertedCoin });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromTrades(coin);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'trades' && message.data[0].coin === convertedCoin) {\n        message = await this.symbolConversion.convertSymbolsInObject(message, ['coin']);\n        callback(message.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'trades', coin: convertedCoin });\n  }\n\n  async subscribeToOrderUpdates(\n    user: string,\n    callback: (data: WsOrder[] & { user: string }) => void\n  ): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('orderUpdates', { user });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromOrderUpdates(user);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'orderUpdates') {\n        message = await this.symbolConversion.convertSymbolsInObject(message);\n        callback(message.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'orderUpdates', user: user });\n  }\n\n  async subscribeToUserEvents(\n    user: string,\n    callback: (data: WsUserEvent & { user: string }) => void\n  ): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('userEvents', { user });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromUserEvents(user);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'userEvents') {\n        message = await this.symbolConversion.convertSymbolsInObject(message);\n        callback(message.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'userEvents', user: user });\n  }\n\n  async subscribeToUserFills(\n    user: string,\n    callback: (data: WsUserFills & { user: string }) => void\n  ): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('userFills', { user });\n\n    // Remove existing subscription if any\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromUserFills(user);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'userFills') {\n        const convertedMessage = await this.symbolConversion.convertSymbolsInObject(message);\n        callback(convertedMessage.data);\n      }\n    };\n\n    // Store the message handler with the callback for cleanup\n    (callback as any).__messageHandler = messageHandler;\n\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'userFills', user });\n  }\n\n  async subscribeToUserFundings(\n    user: string,\n    callback: (data: WsUserFundings & { user: string }) => void\n  ): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('userFundings', { user });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromUserFundings(user);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'userFundings') {\n        message = await this.symbolConversion.convertSymbolsInObject(message);\n        callback(message.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'userFundings', user: user });\n  }\n\n  async subscribeToUserNonFundingLedgerUpdates(\n    user: string,\n    callback: (data: WsUserNonFundingLedgerUpdates & { user: string }) => void\n  ): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('userNonFundingLedgerUpdates', { user });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromUserNonFundingLedgerUpdates(user);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'userNonFundingLedgerUpdates') {\n        message = await this.symbolConversion.convertSymbolsInObject(message);\n        callback(message.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'userNonFundingLedgerUpdates', user: user });\n  }\n\n  async subscribeToUserActiveAssetData(\n    user: string,\n    coin: string,\n    callback: (data: WsUserActiveAssetData & { user: string }) => void\n  ): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('activeAssetData', { user, coin });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromUserActiveAssetData(user, coin);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'activeAssetData') {\n        message = await this.symbolConversion.convertSymbolsInObject(message);\n        callback(message.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'activeAssetData', user: user, coin: coin });\n  }\n\n  /**\n   * Send a POST request via WebSocket\n   * @param requestType - The type of request ('info' or 'action')\n   * @param payload - The payload to send with the request\n   * @param timeout - Optional timeout in milliseconds (default: 30000)\n   * @returns A promise that resolves with the response data\n   */\n  async postRequest(\n    requestType: 'info' | 'action',\n    payload: any,\n    timeout: number = 30000\n  ): Promise<any> {\n    // Ensure WebSocket is connected\n    if (!this.ws.isConnected()) {\n      throw new Error('WebSocket is not connected');\n    }\n\n    // Generate a unique request ID\n    const id = Date.now() + Math.floor(Math.random() * 1000);\n\n    console.log(`Preparing WebSocket POST request (ID: ${id}):`, JSON.stringify(payload));\n\n    // For WebSocket POST requests, we need to use the exchange format (e.g., 'BTC' instead of 'BTC-PERP')\n    // We need to ensure all coin references are in the exchange format\n    let convertedPayload = { ...payload };\n\n    // Helper function to convert a coin to exchange format\n    const convertCoinToExchangeFormat = (coin: string): string => {\n      if (coin && coin.includes('-')) {\n        const parts = coin.split('-');\n        return parts[0]; // Return just the base symbol (e.g., 'BTC' from 'BTC-PERP')\n      }\n      return coin;\n    };\n\n    // Process coin field if it exists\n    if (convertedPayload.coin) {\n      convertedPayload.coin = convertCoinToExchangeFormat(convertedPayload.coin);\n    }\n\n    // Process arrays of coins if they exist\n    if (Array.isArray(convertedPayload.coins)) {\n      convertedPayload.coins = convertedPayload.coins.map(convertCoinToExchangeFormat);\n    }\n\n    // For nested objects like in order requests\n    if (convertedPayload.orders) {\n      convertedPayload.orders = convertedPayload.orders.map((order: any) => {\n        if (order.coin) {\n          return { ...order, coin: convertCoinToExchangeFormat(order.coin) };\n        }\n        return order;\n      });\n    }\n\n    // For cancels which might have coin field\n    if (convertedPayload.cancels) {\n      convertedPayload.cancels = convertedPayload.cancels.map((cancel: any) => {\n        if (cancel.coin) {\n          return { ...cancel, coin: convertCoinToExchangeFormat(cancel.coin) };\n        }\n        return cancel;\n      });\n    }\n\n    // For action.cancels which might have coin field\n    if (convertedPayload.action && convertedPayload.action.cancels) {\n      convertedPayload.action.cancels = convertedPayload.action.cancels.map((cancel: any) => {\n        if (cancel.coin) {\n          return { ...cancel, coin: convertCoinToExchangeFormat(cancel.coin) };\n        }\n        return cancel;\n      });\n    }\n\n    // Create the request object according to Hyperliquid API format\n    const request = {\n      method: 'post',\n      id: id,\n      request: {\n        type: requestType,\n        payload: convertedPayload,\n      },\n    };\n\n    console.log(`Sending WebSocket POST request (ID: ${id}):`, JSON.stringify(request));\n\n    // Send the request\n    this.ws.sendMessage(request);\n\n    // Wait for and process the response\n    return new Promise((resolve, reject) => {\n      let receivedMessages = 0;\n      let timeoutId: NodeJS.Timeout;\n\n      const responseHandler = (message: any) => {\n        // Skip if not an object\n        if (typeof message !== 'object' || message === null) {\n          return;\n        }\n\n        receivedMessages++;\n\n        // For debugging - log every 10th message to avoid flooding the console\n        if (receivedMessages % 10 === 0) {\n          console.log(\n            `Received ${receivedMessages} WebSocket messages while waiting for response to request ${id}`\n          );\n        }\n\n        // Check if this is a post response\n        if (message.channel === 'post') {\n          console.log(`Received post response:`, JSON.stringify(message));\n\n          // Check if this is a response to our request\n          if (message.data && message.data.id === id) {\n            console.log(`Found matching response for request ID ${id}`);\n\n            // Clean up the event listener and timeout\n            this.ws.removeListener('message', responseHandler);\n            if (timeoutId) {\n              clearTimeout(timeoutId);\n            }\n\n            // Handle error responses\n            if (message.data.response && message.data.response.type === 'error') {\n              reject(new Error(message.data.response.payload));\n              return;\n            }\n\n            try {\n              // Extract and convert the response payload\n              let responseData;\n\n              if (message.data.response && message.data.response.payload) {\n                responseData = message.data.response.payload;\n              } else if (message.data.response) {\n                responseData = message.data.response;\n              } else {\n                responseData = message.data;\n              }\n\n              // For the response, we want to convert exchange format back to our internal format\n              // This means adding the '-PERP' suffix to coin symbols\n              const processResponse = (data: any): any => {\n                if (!data || typeof data !== 'object') {\n                  return data;\n                }\n\n                if (Array.isArray(data)) {\n                  return data.map(item => processResponse(item));\n                }\n\n                const result: any = {};\n\n                for (const [key, value] of Object.entries(data)) {\n                  if (key === 'coin' && typeof value === 'string') {\n                    // Convert coin to internal format (add -PERP suffix if not present)\n                    result[key] = value.includes('-') ? value : `${value}-PERP`;\n                  } else if (typeof value === 'object' && value !== null) {\n                    // Recursively process nested objects\n                    result[key] = processResponse(value);\n                  } else {\n                    // Keep other values as is\n                    result[key] = value;\n                  }\n                }\n\n                return result;\n              };\n\n              const processedResponse = processResponse(responseData);\n              resolve(processedResponse);\n            } catch (error) {\n              console.error('Error processing response:', error);\n              reject(error);\n            }\n          }\n        }\n      };\n\n      // Register the response handler\n      this.ws.on('message', responseHandler);\n\n      // Set a timeout to prevent hanging requests\n      timeoutId = setTimeout(() => {\n        this.ws.removeListener('message', responseHandler);\n        console.log(\n          `Request ${id} timed out after ${timeout}ms. Received ${receivedMessages} messages.`\n        );\n        reject(new Error(`WebSocket request timeout after ${timeout}ms`));\n      }, timeout);\n    });\n  }\n\n  async unsubscribeFromAllMids(): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('allMids');\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'allMids' });\n  }\n\n  async unsubscribeFromNotification(user: string): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('notification', { user });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'notification', user: user });\n  }\n\n  async unsubscribeFromWebData2(user: string): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('webData2', { user });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'webData2', user: user });\n  }\n\n  async unsubscribeFromCandle(coin: string, interval: string): Promise<void> {\n    const convertedCoin = await this.symbolConversion.convertSymbol(coin, 'reverse');\n    const subscriptionKey = this.getSubscriptionKey('candle', { coin: convertedCoin, interval });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'candle', coin: convertedCoin, interval: interval });\n  }\n\n  async unsubscribeFromL2Book(coin: string): Promise<void> {\n    const convertedCoin = await this.symbolConversion.convertSymbol(coin, 'reverse');\n    const subscriptionKey = this.getSubscriptionKey('l2Book', { coin: convertedCoin });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'l2Book', coin: convertedCoin });\n  }\n\n  async unsubscribeFromTrades(coin: string): Promise<void> {\n    const convertedCoin = await this.symbolConversion.convertSymbol(coin, 'reverse');\n    const subscriptionKey = this.getSubscriptionKey('trades', { coin: convertedCoin });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'trades', coin: convertedCoin });\n  }\n\n  async unsubscribeFromOrderUpdates(user: string): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('orderUpdates', { user });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'orderUpdates', user: user });\n  }\n\n  async unsubscribeFromUserEvents(user: string): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('userEvents', { user });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'userEvents', user: user });\n  }\n\n  async unsubscribeFromUserFills(user: string): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('userFills', { user });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'userFills', user });\n  }\n\n  async unsubscribeFromUserFundings(user: string): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('userFundings', { user });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'userFundings', user: user });\n  }\n\n  async unsubscribeFromUserNonFundingLedgerUpdates(user: string): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('userNonFundingLedgerUpdates', { user });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'userNonFundingLedgerUpdates', user: user });\n  }\n\n  async unsubscribeFromUserActiveAssetData(user: string, coin: string): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('activeAssetData', { user, coin });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'activeAssetData', user: user, coin: coin });\n  }\n\n  async subscribeToActiveAssetCtx(\n    coin: string,\n    callback: (data: WsActiveAssetCtx) => void\n  ): Promise<void> {\n    const convertedCoin = await this.symbolConversion.convertSymbol(coin, 'reverse');\n    const subscriptionKey = this.getSubscriptionKey('activeAssetCtx', { coin: convertedCoin });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromActiveAssetCtx(coin);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'activeAssetCtx' && message.data.coin === convertedCoin) {\n        const convertedMessage = await this.symbolConversion.convertSymbolsInObject(message);\n        callback(convertedMessage.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'activeAssetCtx', coin: convertedCoin });\n  }\n\n  async subscribeToActiveSpotAssetCtx(\n    coin: string,\n    callback: (data: WsActiveSpotAssetCtx) => void\n  ): Promise<void> {\n    const convertedCoin = await this.symbolConversion.convertSymbol(coin, 'reverse');\n    const subscriptionKey = this.getSubscriptionKey('activeSpotAssetCtx', { coin: convertedCoin });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromActiveSpotAssetCtx(coin);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'activeSpotAssetCtx' && message.data.coin === convertedCoin) {\n        const convertedMessage = await this.symbolConversion.convertSymbolsInObject(message);\n        callback(convertedMessage.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'activeSpotAssetCtx', coin: convertedCoin });\n  }\n\n  async subscribeToUserTwapSliceFills(\n    user: string,\n    callback: (data: WsTwapSliceFill & { user: string }) => void\n  ): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('userTwapSliceFills', { user });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromUserTwapSliceFills(user);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'userTwapSliceFills') {\n        const convertedMessage = await this.symbolConversion.convertSymbolsInObject(message);\n        callback(convertedMessage.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'userTwapSliceFills', user });\n  }\n\n  async subscribeToBbo(coin: string, callback: (data: WsBbo) => void): Promise<void> {\n    const convertedCoin = await this.symbolConversion.convertSymbol(coin, 'reverse');\n    const subscriptionKey = this.getSubscriptionKey('bbo', { coin: convertedCoin });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromBbo(coin);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'bbo' && message.data.coin === convertedCoin) {\n        const convertedMessage = await this.symbolConversion.convertSymbolsInObject(message);\n        callback(convertedMessage.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'bbo', coin: convertedCoin });\n  }\n\n  async subscribeToUserTwapHistory(\n    user: string,\n    callback: (data: WsTwapHistoryResponse) => void\n  ): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('userTwapHistory', { user });\n\n    if (this.activeSubscriptions.has(subscriptionKey)) {\n      await this.unsubscribeFromUserTwapHistory(user);\n    }\n\n    this.addSubscriptionCallback(subscriptionKey, callback);\n\n    const messageHandler = async (message: any) => {\n      if (message.channel === 'userTwapHistory') {\n        const convertedMessage = await this.symbolConversion.convertSymbolsInObject(message);\n        callback(convertedMessage.data);\n      }\n    };\n\n    (callback as any).__messageHandler = messageHandler;\n    this.ws.on('message', messageHandler);\n    await this.subscribe({ type: 'userTwapHistory', user });\n  }\n\n  async unsubscribeFromActiveAssetCtx(coin: string): Promise<void> {\n    const convertedCoin = await this.symbolConversion.convertSymbol(coin, 'reverse');\n    const subscriptionKey = this.getSubscriptionKey('activeAssetCtx', { coin: convertedCoin });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'activeAssetCtx', coin: convertedCoin });\n  }\n\n  async unsubscribeFromActiveSpotAssetCtx(coin: string): Promise<void> {\n    const convertedCoin = await this.symbolConversion.convertSymbol(coin, 'reverse');\n    const subscriptionKey = this.getSubscriptionKey('activeSpotAssetCtx', { coin: convertedCoin });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'activeSpotAssetCtx', coin: convertedCoin });\n  }\n\n  async unsubscribeFromUserTwapSliceFills(user: string): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('userTwapSliceFills', { user });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'userTwapSliceFills', user });\n  }\n\n  async unsubscribeFromBbo(coin: string): Promise<void> {\n    const convertedCoin = await this.symbolConversion.convertSymbol(coin, 'reverse');\n    const subscriptionKey = this.getSubscriptionKey('bbo', { coin: convertedCoin });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'bbo', coin: convertedCoin });\n  }\n\n  async unsubscribeFromUserTwapHistory(user: string): Promise<void> {\n    const subscriptionKey = this.getSubscriptionKey('userTwapHistory', { user });\n    const callbacks = this.activeSubscriptions.get(subscriptionKey);\n\n    if (callbacks) {\n      for (const callback of callbacks) {\n        const messageHandler = (callback as any).__messageHandler;\n        if (messageHandler) {\n          this.ws.removeListener('message', messageHandler);\n          delete (callback as any).__messageHandler;\n        }\n      }\n      this.activeSubscriptions.delete(subscriptionKey);\n    }\n\n    await this.unsubscribe({ type: 'userTwapHistory', user });\n  }\n\n  /**\n   * Resubscribes to all active subscriptions after a WebSocket reconnection\n   */\n  async resubscribeAll(): Promise<void> {\n    console.log('Resubscribing to all active subscriptions after reconnection...');\n\n    // Reset the subscription count since we're starting fresh after reconnection\n    // The count will be incremented for each subscription as we resubscribe\n\n    // Create a copy of the subscription details to avoid modification during iteration\n    const subscriptionsToRestore = new Map(this.subscriptionDetails);\n\n    // Clear the current subscription details as we'll rebuild it\n    this.subscriptionDetails.clear();\n\n    // Resubscribe to each subscription\n    for (const [, details] of subscriptionsToRestore.entries()) {\n      try {\n        console.log(`Resubscribing to ${details.type}`);\n        await this.subscribe(details.params);\n      } catch (error) {\n        console.error(`Failed to resubscribe to ${details.type}:`, error);\n      }\n    }\n\n    console.log('Resubscription complete');\n  }\n}\n","/**\n * Dynamic payload generator for WebSocket POST requests\n *\n * This module provides a unified way to generate signed payloads for all exchange methods\n * without hardcoding each method in the exchange.ts file. It dynamically creates payloads\n * based on method configurations and handles signing automatically.\n */\n\nimport { ethers } from 'ethers';\nimport { ExchangeType, CHAIN_IDS } from '../types/constants';\nimport {\n  signL1Action,\n  signUserSignedAction,\n  signAgent,\n  signUsdTransferAction,\n  orderToWire,\n  removeTrailingZeros,\n} from '../utils/signing';\n\nexport interface PayloadMethodConfig {\n  /** Exchange method type */\n  type: ExchangeType;\n  /** Signing method to use */\n  signingMethod: 'l1Action' | 'userSignedAction' | 'agent' | 'usdTransfer';\n  /** For userSignedAction: the types array for EIP-712 signing */\n  signatureTypes?: Array<{ name: string; type: string }>;\n  /** For userSignedAction: the primary type name */\n  primaryType?: string;\n  /** Whether this method requires asset index conversion */\n  requiresAssetIndex?: boolean;\n  /** Whether this method requires vault address */\n  requiresVaultAddress?: boolean;\n  /** Custom payload transformer function */\n  payloadTransformer?: (params: any, context: PayloadGenerationContext) => any | Promise<any>;\n  /** Whether to include hyperliquidChain and signatureChainId */\n  includeChainInfo?: boolean;\n}\n\nexport interface PayloadGenerationContext {\n  isMainnet: boolean;\n  generateNonce: () => number;\n  getAssetIndex: (coin: string) => Promise<number>;\n  getVaultAddress: () => string | null;\n  wallet: ethers.Wallet;\n}\n\n/**\n * Configuration for all exchange methods\n */\nexport const EXCHANGE_METHOD_CONFIGS: Record<string, PayloadMethodConfig> = {\n  // Order management\n  placeOrder: {\n    type: ExchangeType.ORDER,\n    signingMethod: 'l1Action',\n    requiresAssetIndex: true,\n    requiresVaultAddress: true,\n    payloadTransformer: async (params, context) => {\n      const { orders, grouping = 'na' } = params;\n      const wireOrders = await Promise.all(\n        orders.map(async (order: any) => {\n          const normalizedOrder = { ...order };\n          if (typeof normalizedOrder.limit_px === 'string') {\n            normalizedOrder.limit_px = removeTrailingZeros(normalizedOrder.limit_px);\n          }\n          if (typeof normalizedOrder.sz === 'string') {\n            normalizedOrder.sz = removeTrailingZeros(normalizedOrder.sz);\n          }\n          const assetIndex = await context.getAssetIndex(normalizedOrder.coin);\n          return orderToWire(normalizedOrder, assetIndex);\n        })\n      );\n      return {\n        type: ExchangeType.ORDER,\n        orders: wireOrders,\n        grouping,\n      };\n    },\n  },\n\n  cancelOrder: {\n    type: ExchangeType.CANCEL,\n    signingMethod: 'l1Action',\n    requiresAssetIndex: true,\n    requiresVaultAddress: true,\n    payloadTransformer: async (params, context) => {\n      const cancels = Array.isArray(params.cancels) ? params.cancels : [params];\n      const cancelsWithIndices = await Promise.all(\n        cancels.map(async (cancel: any) => {\n          if (cancel.coin) {\n            const assetIndex = await context.getAssetIndex(cancel.coin);\n            return { a: assetIndex, o: cancel.o };\n          }\n          return cancel;\n        })\n      );\n      return {\n        type: ExchangeType.CANCEL,\n        cancels: cancelsWithIndices,\n      };\n    },\n  },\n\n  modifyOrder: {\n    type: ExchangeType.MODIFY,\n    signingMethod: 'l1Action',\n    requiresAssetIndex: true,\n    requiresVaultAddress: true,\n    payloadTransformer: async (params, context) => {\n      const { oid, order } = params;\n      const normalizedOrder = { ...order };\n      if (typeof normalizedOrder.limit_px === 'string') {\n        normalizedOrder.limit_px = removeTrailingZeros(normalizedOrder.limit_px);\n      }\n      if (typeof normalizedOrder.sz === 'string') {\n        normalizedOrder.sz = removeTrailingZeros(normalizedOrder.sz);\n      }\n      const assetIndex = await context.getAssetIndex(normalizedOrder.coin);\n      return {\n        type: ExchangeType.MODIFY,\n        oid,\n        order: orderToWire(normalizedOrder, assetIndex),\n      };\n    },\n  },\n\n  // Transfer methods\n  transferBetweenSpotAndPerp: {\n    type: ExchangeType.USD_CLASS_TRANSFER,\n    signingMethod: 'userSignedAction',\n    includeChainInfo: true,\n    signatureTypes: [\n      { name: 'hyperliquidChain', type: 'string' },\n      { name: 'amount', type: 'string' },\n      { name: 'toPerp', type: 'bool' },\n      { name: 'nonce', type: 'uint64' },\n    ],\n    primaryType: 'HyperliquidTransaction:UsdClassTransfer',\n    payloadTransformer: (params, context) => ({\n      type: ExchangeType.USD_CLASS_TRANSFER,\n      hyperliquidChain: context.isMainnet ? 'Mainnet' : 'Testnet',\n      signatureChainId: context.isMainnet ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n      amount: params.amount.toString(),\n      toPerp: params.toPerp,\n      nonce: context.generateNonce(),\n    }),\n  },\n\n  usdTransfer: {\n    type: ExchangeType.USD_SEND,\n    signingMethod: 'usdTransfer',\n    includeChainInfo: true,\n    payloadTransformer: (params, context) => ({\n      type: ExchangeType.USD_SEND,\n      hyperliquidChain: context.isMainnet ? 'Mainnet' : 'Testnet',\n      signatureChainId: context.isMainnet ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n      destination: params.destination,\n      amount: params.amount.toString(),\n      time: Date.now(),\n    }),\n  },\n\n  spotTransfer: {\n    type: ExchangeType.SPOT_SEND,\n    signingMethod: 'usdTransfer',\n    includeChainInfo: true,\n    payloadTransformer: (params, context) => ({\n      type: ExchangeType.SPOT_SEND,\n      hyperliquidChain: context.isMainnet ? 'Mainnet' : 'Testnet',\n      signatureChainId: context.isMainnet ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n      destination: params.destination,\n      token: params.token,\n      amount: params.amount,\n      time: Date.now(),\n    }),\n  },\n\n  // Vault operations\n  vaultTransfer: {\n    type: ExchangeType.VAULT_TRANSFER,\n    signingMethod: 'l1Action',\n    payloadTransformer: params => ({\n      type: ExchangeType.VAULT_TRANSFER,\n      vaultAddress: params.vaultAddress,\n      isDeposit: params.isDeposit,\n      usd: params.usd,\n    }),\n  },\n\n  // Agent operations\n  approveAgent: {\n    type: ExchangeType.APPROVE_AGENT,\n    signingMethod: 'agent',\n    includeChainInfo: true,\n    payloadTransformer: (params, context) => ({\n      type: ExchangeType.APPROVE_AGENT,\n      hyperliquidChain: context.isMainnet ? 'Mainnet' : 'Testnet',\n      signatureChainId: context.isMainnet ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n      agentAddress: params.agentAddress,\n      agentName: params.agentName,\n      nonce: context.generateNonce(),\n    }),\n  },\n\n  approveBuilderFee: {\n    type: ExchangeType.APPROVE_BUILDER_FEE,\n    signingMethod: 'userSignedAction',\n    includeChainInfo: true,\n    signatureTypes: [\n      { name: 'hyperliquidChain', type: 'string' },\n      { name: 'maxFeeRate', type: 'string' },\n      { name: 'builder', type: 'address' },\n      { name: 'nonce', type: 'uint64' },\n    ],\n    primaryType: 'HyperliquidTransaction:ApproveBuilderFee',\n    payloadTransformer: (params, context) => ({\n      type: ExchangeType.APPROVE_BUILDER_FEE,\n      hyperliquidChain: context.isMainnet ? 'Mainnet' : 'Testnet',\n      signatureChainId: context.isMainnet ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n      maxFeeRate: params.maxFeeRate.endsWith('%') ? params.maxFeeRate : `${params.maxFeeRate}%`,\n      builder: params.builder.toLowerCase(),\n      nonce: Date.now(),\n    }),\n  },\n\n  // Withdrawal\n  initiateWithdrawal: {\n    type: ExchangeType.WITHDRAW,\n    signingMethod: 'usdTransfer',\n    includeChainInfo: true,\n    payloadTransformer: (params, context) => ({\n      type: ExchangeType.WITHDRAW,\n      hyperliquidChain: context.isMainnet ? 'Mainnet' : 'Testnet',\n      signatureChainId: context.isMainnet ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n      amount: params.amount.toString(),\n      time: Date.now(),\n      destination: params.destination,\n    }),\n  },\n\n  // TWAP orders\n  placeTwapOrder: {\n    type: ExchangeType.TWAP_ORDER,\n    signingMethod: 'l1Action',\n    requiresAssetIndex: true,\n    requiresVaultAddress: true,\n    payloadTransformer: async (params, context) => {\n      const assetIndex = await context.getAssetIndex(params.coin);\n      return {\n        type: ExchangeType.TWAP_ORDER,\n        twap: {\n          a: assetIndex,\n          b: params.is_buy,\n          s: params.sz.toString(),\n          r: params.reduce_only,\n          m: params.minutes,\n          t: params.randomize,\n        },\n      };\n    },\n  },\n\n  // Schedule cancel\n  scheduleCancel: {\n    type: ExchangeType.SCHEDULE_CANCEL,\n    signingMethod: 'l1Action',\n    payloadTransformer: params => ({\n      type: ExchangeType.SCHEDULE_CANCEL,\n      time: params.time,\n    }),\n  },\n\n  // Staking operations\n  cDeposit: {\n    type: ExchangeType.C_DEPOSIT,\n    signingMethod: 'userSignedAction',\n    includeChainInfo: true,\n    signatureTypes: [\n      { name: 'hyperliquidChain', type: 'string' },\n      { name: 'wei', type: 'string' },\n      { name: 'nonce', type: 'uint64' },\n    ],\n    primaryType: 'HyperliquidTransaction:CDeposit',\n    payloadTransformer: (params, context) => ({\n      type: ExchangeType.C_DEPOSIT,\n      hyperliquidChain: context.isMainnet ? 'Mainnet' : 'Testnet',\n      signatureChainId: context.isMainnet ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n      wei: params.wei.toString(),\n      nonce: context.generateNonce(),\n    }),\n  },\n\n  cWithdraw: {\n    type: ExchangeType.C_WITHDRAW,\n    signingMethod: 'userSignedAction',\n    includeChainInfo: true,\n    signatureTypes: [\n      { name: 'hyperliquidChain', type: 'string' },\n      { name: 'wei', type: 'string' },\n      { name: 'nonce', type: 'uint64' },\n    ],\n    primaryType: 'HyperliquidTransaction:CWithdraw',\n    payloadTransformer: (params, context) => ({\n      type: ExchangeType.C_WITHDRAW,\n      hyperliquidChain: context.isMainnet ? 'Mainnet' : 'Testnet',\n      signatureChainId: context.isMainnet ? CHAIN_IDS.ARBITRUM_MAINNET : CHAIN_IDS.ARBITRUM_TESTNET,\n      wei: params.wei.toString(),\n      nonce: context.generateNonce(),\n    }),\n  },\n};\n\n/**\n * Dynamic payload generator class\n */\nexport class PayloadGenerator {\n  constructor(private context: PayloadGenerationContext) {}\n\n  /**\n   * Generate a signed payload for any exchange method\n   * @param methodName The name of the exchange method\n   * @param params The parameters for the method\n   * @returns A signed payload ready for WebSocket POST\n   */\n  async generatePayload(methodName: string, params: any): Promise<any> {\n    const config = EXCHANGE_METHOD_CONFIGS[methodName];\n    if (!config) {\n      throw new Error(`Unknown exchange method: ${methodName}`);\n    }\n\n    try {\n      // Transform the parameters into the action object\n      let action: any;\n      if (config.payloadTransformer) {\n        action = await config.payloadTransformer(params, this.context);\n      } else {\n        action = { type: config.type, ...params };\n      }\n\n      // Generate nonce\n      const nonce = this.context.generateNonce();\n\n      // Get vault address if required\n      const vaultAddress = config.requiresVaultAddress ? this.context.getVaultAddress() : null;\n\n      // Sign the action based on the signing method\n      let signature: any;\n      switch (config.signingMethod) {\n        case 'l1Action':\n          signature = await signL1Action(\n            this.context.wallet,\n            action,\n            vaultAddress,\n            nonce,\n            this.context.isMainnet\n          );\n          break;\n\n        case 'userSignedAction':\n          if (!config.signatureTypes || !config.primaryType) {\n            throw new Error(`Missing signature configuration for method: ${methodName}`);\n          }\n          signature = await signUserSignedAction(\n            this.context.wallet,\n            action,\n            config.signatureTypes,\n            config.primaryType,\n            this.context.isMainnet\n          );\n          break;\n\n        case 'agent':\n          signature = await signAgent(this.context.wallet, action, this.context.isMainnet);\n          break;\n\n        case 'usdTransfer':\n          signature = await signUsdTransferAction(\n            this.context.wallet,\n            action,\n            this.context.isMainnet\n          );\n          break;\n\n        default:\n          throw new Error(`Unknown signing method: ${config.signingMethod}`);\n      }\n\n      // Build the final payload\n      const payload: any = {\n        action,\n        nonce: action.nonce || nonce,\n        signature,\n      };\n\n      if (vaultAddress) {\n        payload.vaultAddress = vaultAddress;\n      }\n\n      return payload;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      throw new Error(`Failed to generate payload for ${methodName}: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Get available exchange methods\n   */\n  getAvailableMethods(): string[] {\n    return Object.keys(EXCHANGE_METHOD_CONFIGS);\n  }\n\n  /**\n   * Check if a method is supported\n   */\n  isMethodSupported(methodName: string): boolean {\n    return methodName in EXCHANGE_METHOD_CONFIGS;\n  }\n}\n","/**\n * WebSocket Payload Manager\n *\n * This module provides a high-level interface for generating and sending\n * exchange method payloads via WebSocket POST requests. It integrates with\n * the dynamic payload generator and WebSocket subscriptions.\n */\n\nimport { ethers } from 'ethers';\nimport { PayloadGenerator, PayloadGenerationContext } from './payload-generator';\nimport { WebSocketSubscriptions } from './subscriptions';\nimport { CustomOperations } from '../rest/custom';\nimport { SymbolConversion } from '../utils/symbolConversion';\n\nexport interface PayloadManagerConfig {\n  wallet: ethers.Wallet;\n  isMainnet: boolean;\n  symbolConversion: SymbolConversion;\n  subscriptions: WebSocketSubscriptions;\n  vaultAddress?: string | null;\n  generateNonce: () => number;\n  customOperations: CustomOperations;\n}\n\n/**\n * WebSocket Payload Manager\n * Provides a unified interface for all exchange operations via WebSocket POST\n */\nexport class WebSocketPayloadManager {\n  private payloadGenerator: PayloadGenerator;\n  private subscriptions: WebSocketSubscriptions;\n  private symbolConversion: SymbolConversion;\n  private vaultAddress: string | null;\n  private customOperations: CustomOperations;\n\n  constructor(config: PayloadManagerConfig) {\n    this.subscriptions = config.subscriptions;\n    this.symbolConversion = config.symbolConversion;\n    this.vaultAddress = config.vaultAddress || null;\n    this.customOperations = config.customOperations;\n\n    // Create payload generation context\n    const context: PayloadGenerationContext = {\n      isMainnet: config.isMainnet,\n      generateNonce: config.generateNonce,\n      getAssetIndex: this.getAssetIndex.bind(this),\n      getVaultAddress: () => this.vaultAddress,\n      wallet: config.wallet,\n    };\n\n    this.payloadGenerator = new PayloadGenerator(context);\n  }\n\n  /**\n   * Get asset index for a coin symbol\n   */\n  private async getAssetIndex(coin: string): Promise<number> {\n    const index = await this.symbolConversion.getAssetIndex(coin);\n    if (index === undefined) {\n      throw new Error(`Asset index not found for coin: ${coin}`);\n    }\n    return index;\n  }\n\n  /**\n   * Execute any exchange method via WebSocket POST\n   * @param methodName The exchange method name\n   * @param params The method parameters\n   * @param timeout Optional timeout in milliseconds\n   * @returns The response from the WebSocket POST request\n   */\n  async executeMethod(methodName: string, params: any, timeout: number = 30000): Promise<any> {\n    try {\n      // Generate the signed payload\n      const payload = await this.payloadGenerator.generatePayload(methodName, params);\n\n      // Send via WebSocket POST\n      const response = await this.subscriptions.postRequest('action', payload, timeout);\n\n      return response;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      throw new Error(`Failed to execute ${methodName}: ${errorMessage}`);\n    }\n  }\n\n  // ==================== ORDER MANAGEMENT ====================\n\n  /**\n   * Place an order via WebSocket POST\n   */\n  async placeOrder(orderParams: {\n    coin: string;\n    is_buy: boolean;\n    sz: string | number;\n    limit_px: string | number;\n    order_type: any;\n    reduce_only: boolean;\n    cloid?: string;\n  }): Promise<any> {\n    const orders = [orderParams];\n    return this.executeMethod('placeOrder', { orders });\n  }\n\n  /**\n   * Place multiple orders via WebSocket POST\n   */\n  async placeOrders(orders: any[], grouping: string = 'na'): Promise<any> {\n    return this.executeMethod('placeOrder', { orders, grouping });\n  }\n\n  /**\n   * Cancel an order via WebSocket POST\n   */\n  async cancelOrder(cancelParams: { coin: string; o: number | string }): Promise<any> {\n    return this.executeMethod('cancelOrder', { cancels: [cancelParams] });\n  }\n\n  /**\n   * Cancel multiple orders via WebSocket POST\n   */\n  async cancelOrders(cancels: any[]): Promise<any> {\n    return this.executeMethod('cancelOrder', { cancels });\n  }\n\n  /**\n   * Cancel all orders via WebSocket POST\n   * This is a custom composite operation that uses native methods\n   */\n  async cancelAllOrders(): Promise<any> {\n    // Use the custom operations to get the cancel all orders implementation\n    // This will internally use native methods like getting open orders and canceling them\n    return this.customOperations.cancelAllOrders();\n  }\n\n  /**\n   * Modify an order via WebSocket POST\n   */\n  async modifyOrder(modifyParams: { oid: number | string; order: any }): Promise<any> {\n    return this.executeMethod('modifyOrder', modifyParams);\n  }\n\n  // ==================== TRANSFER OPERATIONS ====================\n\n  /**\n   * Transfer between spot and perp wallets via WebSocket POST\n   */\n  async transferBetweenSpotAndPerp(amount: number, toPerp: boolean): Promise<any> {\n    return this.executeMethod('transferBetweenSpotAndPerp', { amount, toPerp });\n  }\n\n  /**\n   * Transfer USDC to another address via WebSocket POST\n   */\n  async usdTransfer(destination: string, amount: number): Promise<any> {\n    return this.executeMethod('usdTransfer', { destination, amount });\n  }\n\n  /**\n   * Transfer spot tokens to another address via WebSocket POST\n   */\n  async spotTransfer(destination: string, token: string, amount: string): Promise<any> {\n    return this.executeMethod('spotTransfer', { destination, token, amount });\n  }\n\n  // ==================== VAULT OPERATIONS ====================\n\n  /**\n   * Transfer to/from vault via WebSocket POST\n   */\n  async vaultTransfer(vaultAddress: string, isDeposit: boolean, usd: number): Promise<any> {\n    return this.executeMethod('vaultTransfer', { vaultAddress, isDeposit, usd });\n  }\n\n  // ==================== AGENT OPERATIONS ====================\n\n  /**\n   * Approve an agent via WebSocket POST\n   */\n  async approveAgent(agentAddress: string, agentName: string): Promise<any> {\n    return this.executeMethod('approveAgent', { agentAddress, agentName });\n  }\n\n  /**\n   * Approve builder fee via WebSocket POST\n   */\n  async approveBuilderFee(builder: string, maxFeeRate: string): Promise<any> {\n    return this.executeMethod('approveBuilderFee', { builder, maxFeeRate });\n  }\n\n  // ==================== WITHDRAWAL ====================\n\n  /**\n   * Initiate withdrawal via WebSocket POST\n   */\n  async initiateWithdrawal(destination: string, amount: number): Promise<any> {\n    return this.executeMethod('initiateWithdrawal', { destination, amount });\n  }\n\n  // ==================== TWAP ORDERS ====================\n\n  /**\n   * Place TWAP order via WebSocket POST\n   */\n  async placeTwapOrder(twapParams: {\n    coin: string;\n    is_buy: boolean;\n    sz: number;\n    reduce_only: boolean;\n    minutes: number;\n    randomize: boolean;\n  }): Promise<any> {\n    return this.executeMethod('placeTwapOrder', twapParams);\n  }\n\n  // ==================== SCHEDULE OPERATIONS ====================\n\n  /**\n   * Schedule cancel via WebSocket POST\n   */\n  async scheduleCancel(time: number | null): Promise<any> {\n    return this.executeMethod('scheduleCancel', { time });\n  }\n\n  // ==================== STAKING OPERATIONS ====================\n\n  /**\n   * Deposit into staking via WebSocket POST\n   */\n  async cDeposit(wei: bigint): Promise<any> {\n    return this.executeMethod('cDeposit', { wei });\n  }\n\n  /**\n   * Withdraw from staking via WebSocket POST\n   */\n  async cWithdraw(wei: bigint): Promise<any> {\n    return this.executeMethod('cWithdraw', { wei });\n  }\n\n  // ==================== CUSTOM MARKET OPERATIONS ====================\n\n  /**\n   * Market buy/sell via WebSocket POST\n   * This is a custom composite operation that uses native methods\n   */\n  async marketOpen(\n    symbol: string,\n    isBuy: boolean,\n    size: number,\n    px?: number,\n    slippage: number = 0.05,\n    cloid?: string\n  ): Promise<any> {\n    return this.customOperations.marketOpen(symbol, isBuy, size, px, slippage, cloid);\n  }\n\n  /**\n   * Market close position via WebSocket POST\n   * This is a custom composite operation that uses native methods\n   */\n  async marketClose(\n    symbol: string,\n    size?: number,\n    px?: number,\n    slippage: number = 0.05,\n    cloid?: string\n  ): Promise<any> {\n    return this.customOperations.marketClose(symbol, size, px, slippage, cloid);\n  }\n\n  /**\n   * Close all positions via WebSocket POST\n   * This is a custom composite operation that uses native methods\n   */\n  async closeAllPositions(slippage: number = 0.05): Promise<any> {\n    return this.customOperations.closeAllPositions(slippage);\n  }\n\n  // ==================== UTILITY METHODS ====================\n\n  /**\n   * Get all available exchange methods\n   */\n  getAvailableMethods(): string[] {\n    return this.payloadGenerator.getAvailableMethods();\n  }\n\n  /**\n   * Check if a method is supported\n   */\n  isMethodSupported(methodName: string): boolean {\n    return this.payloadGenerator.isMethodSupported(methodName);\n  }\n\n  /**\n   * Execute a custom method with raw parameters\n   * Useful for methods not yet wrapped in convenience functions\n   */\n  async executeCustomMethod(methodName: string, params: any, timeout?: number): Promise<any> {\n    return this.executeMethod(methodName, params, timeout);\n  }\n\n  /**\n   * Generate payload without executing (for testing/debugging)\n   */\n  async generatePayload(methodName: string, params: any): Promise<any> {\n    return this.payloadGenerator.generatePayload(methodName, params);\n  }\n\n  /**\n   * Update vault address\n   */\n  setVaultAddress(vaultAddress: string | null): void {\n    this.vaultAddress = vaultAddress;\n  }\n\n  /**\n   * Get current vault address\n   */\n  getVaultAddress(): string | null {\n    return this.vaultAddress;\n  }\n}\n\n/**\n * Factory function to create a WebSocket Payload Manager\n */\nexport function createWebSocketPayloadManager(\n  config: PayloadManagerConfig\n): WebSocketPayloadManager {\n  return new WebSocketPayloadManager(config);\n}\n","export class RateLimiter {\n  private tokens: number;\n  private lastRefill: number;\n  private readonly capacity: number;\n  private readonly refillRate: number; // tokens per second\n\n  constructor() {\n    this.capacity = 100; // 100 tokens maximum as per API docs\n    this.refillRate = 10; // 10 tokens per second as per API docs\n    this.tokens = this.capacity;\n    this.lastRefill = Date.now();\n  }\n\n  private refillTokens() {\n    const now = Date.now();\n    const elapsedSeconds = (now - this.lastRefill) / 1000; // convert to seconds\n\n    // Calculate new tokens based on elapsed time and refill rate\n    const newTokens = elapsedSeconds * this.refillRate;\n\n    if (newTokens > 0) {\n      this.tokens = Math.min(this.capacity, this.tokens + newTokens);\n      this.lastRefill = now;\n    }\n  }\n\n  async waitForToken(weight: number = 1): Promise<void> {\n    this.refillTokens();\n\n    if (this.tokens >= weight) {\n      this.tokens -= weight;\n      return;\n    }\n\n    // Calculate wait time needed for enough tokens to be available\n    const tokensNeeded = weight - this.tokens;\n    const waitTimeMs = (tokensNeeded / this.refillRate) * 1000;\n\n    return new Promise(resolve => setTimeout(resolve, waitTimeMs)).then(() => {\n      this.refillTokens();\n      return this.waitForToken(weight); // recursively check again after waiting\n    });\n  }\n}\n","// src/rest/custom.ts\n\nimport { ethers } from 'ethers';\nimport { InfoAPI } from './info';\nimport { ExchangeAPI } from './exchange';\nimport { UserOpenOrders } from '../types';\nimport { OrderResponse, CancelOrderRequest, OrderRequest, OrderType } from '../types/index';\nimport { CancelOrderResponse } from '../utils/signing';\nimport { SymbolConversion } from '../utils/symbolConversion';\nimport { floatToWire } from '../utils/signing';\nimport { Hyperliquid } from '../index';\n\nexport class CustomOperations {\n  private exchange: ExchangeAPI;\n  private infoApi: InfoAPI;\n  private wallet?: ethers.Wallet;\n  private symbolConversion: SymbolConversion;\n  private walletAddress: string | null;\n  private parent?: Hyperliquid;\n\n  constructor(\n    exchangeOrParent: ExchangeAPI | Hyperliquid,\n    infoApiOrPrivateKey?: InfoAPI | string,\n    privateKeyOrSymbolConversion?: string | SymbolConversion,\n    symbolConversionOrWalletAddress?: SymbolConversion | string | null,\n    walletAddress?: string | null\n  ) {\n    // Check if first argument is Hyperliquid instance\n    if (exchangeOrParent instanceof Hyperliquid) {\n      this.parent = exchangeOrParent;\n      this.exchange = exchangeOrParent.exchange;\n      this.infoApi = exchangeOrParent.info;\n      this.symbolConversion = exchangeOrParent.symbolConversion;\n      this.walletAddress = exchangeOrParent.isAuthenticated()\n        ? exchangeOrParent.isAuthenticated().toString()\n        : null;\n    } else {\n      // Original constructor\n      this.exchange = exchangeOrParent;\n      this.infoApi = infoApiOrPrivateKey as InfoAPI;\n      if (privateKeyOrSymbolConversion && typeof privateKeyOrSymbolConversion === 'string') {\n        this.wallet = new ethers.Wallet(privateKeyOrSymbolConversion);\n      }\n      this.symbolConversion = symbolConversionOrWalletAddress as SymbolConversion;\n      this.walletAddress = walletAddress || null;\n    }\n  }\n\n  private getUserAddress(): string {\n    if (!this.walletAddress && !this.wallet?.address) {\n      throw new Error(\n        'No wallet address available. Please provide a wallet address or private key.'\n      );\n    }\n    return this.walletAddress || this.wallet!.address;\n  }\n\n  async cancelAllOrders(symbol?: string): Promise<CancelOrderResponse> {\n    try {\n      const address = this.getUserAddress();\n      const openOrders: UserOpenOrders = await this.infoApi.getUserOpenOrders(address);\n\n      let ordersToCancel: UserOpenOrders;\n\n      for (let order of openOrders) {\n        order.coin = await this.symbolConversion.convertSymbol(order.coin);\n      }\n\n      if (symbol) {\n        ordersToCancel = openOrders.filter(order => order.coin === symbol);\n      } else {\n        ordersToCancel = openOrders;\n      }\n\n      if (ordersToCancel.length === 0) {\n        throw new Error('No orders to cancel');\n      }\n\n      const cancelRequests: CancelOrderRequest[] = ordersToCancel.map(order => ({\n        coin: order.coin,\n        o: order.oid,\n      }));\n\n      const response = await this.exchange.cancelOrder(cancelRequests);\n      return response;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async getAllAssets(): Promise<{ perp: string[]; spot: string[] }> {\n    return await this.symbolConversion.getAllAssets();\n  }\n\n  private DEFAULT_SLIPPAGE = 0.05;\n\n  private async getSlippagePrice(\n    symbol: string,\n    isBuy: boolean,\n    slippage: number,\n    px?: number\n  ): Promise<number> {\n    const convertedSymbol = await this.symbolConversion.convertSymbol(symbol);\n    if (!px) {\n      const allMids = await this.infoApi.getAllMids();\n      px = Number(allMids[convertedSymbol]);\n    }\n\n    const isSpot = symbol.includes('-SPOT');\n\n    //If not isSpot count how many decimals price has to use the same amount for rounding\n    const decimals = px.toString().split('.')[1]?.length || 0;\n\n    console.log(decimals);\n\n    px *= isBuy ? 1 + slippage : 1 - slippage;\n    return Number(px.toFixed(isSpot ? 8 : Math.max(0, decimals - 1)));\n  }\n\n  async marketOpen(\n    symbol: string,\n    isBuy: boolean,\n    size: number,\n    px?: number,\n    slippage: number = this.DEFAULT_SLIPPAGE,\n    cloid?: string\n  ): Promise<OrderResponse> {\n    const convertedSymbol = await this.symbolConversion.convertSymbol(symbol);\n    const slippagePrice = await this.getSlippagePrice(convertedSymbol, isBuy, slippage, px);\n    console.log('Slippage Price: ', slippagePrice);\n\n    const orderRequest: OrderRequest = {\n      coin: convertedSymbol,\n      is_buy: isBuy,\n      sz: size,\n      limit_px: slippagePrice,\n      order_type: { limit: { tif: 'Ioc' } } as OrderType,\n      reduce_only: false,\n    };\n\n    if (cloid) {\n      orderRequest.cloid = cloid;\n    }\n    console.log(orderRequest);\n    return this.exchange.placeOrder(orderRequest);\n  }\n\n  async marketClose(\n    symbol: string,\n    size?: number,\n    px?: number,\n    slippage: number = this.DEFAULT_SLIPPAGE,\n    cloid?: string\n  ): Promise<OrderResponse> {\n    const convertedSymbol = await this.symbolConversion.convertSymbol(symbol);\n    const address = this.getUserAddress();\n    const positions = await this.infoApi.perpetuals.getClearinghouseState(address);\n    for (const position of positions.assetPositions) {\n      const item = position.position;\n      if (convertedSymbol !== item.coin) {\n        continue;\n      }\n      const szi = parseFloat(item.szi);\n      const closeSize = size || Math.abs(szi);\n      const isBuy = szi < 0;\n\n      // Get aggressive Market Price\n      const slippagePrice = await this.getSlippagePrice(convertedSymbol, isBuy, slippage, px);\n\n      // Market Order is an aggressive Limit Order IoC\n      const orderRequest: OrderRequest = {\n        coin: convertedSymbol,\n        is_buy: isBuy,\n        sz: closeSize,\n        limit_px: slippagePrice,\n        order_type: { limit: { tif: 'Ioc' } } as OrderType,\n        reduce_only: true,\n      };\n\n      if (cloid) {\n        orderRequest.cloid = cloid;\n      }\n\n      return this.exchange.placeOrder(orderRequest);\n    }\n\n    throw new Error(`No position found for ${convertedSymbol}`);\n  }\n\n  async closeAllPositions(slippage: number = this.DEFAULT_SLIPPAGE): Promise<OrderResponse[]> {\n    try {\n      const address = this.getUserAddress();\n      const positions = await this.infoApi.perpetuals.getClearinghouseState(address);\n      const closeOrders: Promise<OrderResponse>[] = [];\n\n      console.log(positions);\n\n      for (const position of positions.assetPositions) {\n        const item = position.position;\n        if (parseFloat(item.szi) !== 0) {\n          const symbol = await this.symbolConversion.convertSymbol(item.coin, 'forward');\n          closeOrders.push(this.marketClose(symbol, undefined, undefined, slippage));\n        }\n      }\n\n      return await Promise.all(closeOrders);\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n","import { HttpApi } from './helpers';\nimport * as CONSTANTS from '../types/constants';\nimport { MetaAndAssetCtxs, SpotMetaAndAssetCtxs } from '../types';\n\nexport class SymbolConversion {\n  private assetToIndexMap: Map<string, number> = new Map();\n  private exchangeToInternalNameMap: Map<string, string> = new Map();\n  private httpApi: HttpApi;\n  private refreshIntervalMs: number;\n  private refreshInterval: any = null;\n  private initialized: boolean = false;\n  private consecutiveFailures: number = 0;\n  private maxConsecutiveFailures: number = 5;\n  private baseRetryDelayMs: number = 1000;\n  private disableAssetMapRefresh: boolean;\n\n  constructor(\n    baseURL: string,\n    rateLimiter: any,\n    disableAssetMapRefresh: boolean = false,\n    refreshIntervalMs: number = 60000\n  ) {\n    this.httpApi = new HttpApi(baseURL, CONSTANTS.ENDPOINTS.INFO, rateLimiter);\n    this.disableAssetMapRefresh = disableAssetMapRefresh;\n    this.refreshIntervalMs = refreshIntervalMs;\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      await this.refreshAssetMaps();\n\n      // Only start periodic refresh if not disabled\n      if (!this.disableAssetMapRefresh) {\n        this.startPeriodicRefresh();\n      }\n\n      this.initialized = true;\n    } catch (error) {\n      console.error('Failed to initialize SymbolConversion:', error);\n      throw error;\n    }\n  }\n\n  private async ensureInitialized(): Promise<void> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n  }\n\n  async getInternalName(exchangeName: string): Promise<string | undefined> {\n    await this.ensureInitialized();\n    return this.exchangeToInternalNameMap.get(exchangeName);\n  }\n\n  private startPeriodicRefresh(): void {\n    if (this.refreshInterval !== null) {\n      clearInterval(this.refreshInterval);\n    }\n\n    // Use standard setInterval that works in both Node.js and browser\n    this.refreshInterval = setInterval(() => {\n      this.refreshAssetMaps().catch(error => {\n        console.error('Failed to refresh asset maps:', error);\n        // Increment consecutive failures counter\n        this.consecutiveFailures++;\n\n        // If we've reached the maximum number of consecutive failures, stop refreshing\n        if (this.consecutiveFailures >= this.maxConsecutiveFailures) {\n          console.warn(\n            `Maximum consecutive failures (${this.maxConsecutiveFailures}) reached. Stopping automatic refresh.`\n          );\n          this.stopPeriodicRefresh();\n        }\n      });\n    }, this.refreshIntervalMs);\n  }\n\n  // Check if max failures has been reached and stop refresh if needed\n  private checkMaxFailures(): void {\n    if (this.consecutiveFailures >= this.maxConsecutiveFailures) {\n      console.warn(\n        `Maximum consecutive failures (${this.maxConsecutiveFailures}) reached. Stopping automatic refresh.`\n      );\n      this.stopPeriodicRefresh();\n    }\n  }\n\n  public stopPeriodicRefresh(): void {\n    if (this.refreshInterval !== null) {\n      clearInterval(this.refreshInterval);\n      this.refreshInterval = null;\n    }\n  }\n\n  public enablePeriodicRefresh(): void {\n    if (!this.disableAssetMapRefresh && this.initialized) {\n      this.startPeriodicRefresh();\n    }\n  }\n\n  public disablePeriodicRefresh(): void {\n    this.stopPeriodicRefresh();\n  }\n\n  public isRefreshEnabled(): boolean {\n    return !this.disableAssetMapRefresh && this.refreshInterval !== null;\n  }\n\n  public getRefreshInterval(): number {\n    return this.refreshIntervalMs;\n  }\n\n  public setRefreshInterval(intervalMs: number): void {\n    this.refreshIntervalMs = intervalMs;\n    if (this.refreshInterval !== null) {\n      // Restart with new interval\n      this.stopPeriodicRefresh();\n      this.startPeriodicRefresh();\n    }\n  }\n\n  private async refreshAssetMaps(): Promise<void> {\n    try {\n      const [perpMeta, spotMeta] = await Promise.all([\n        this.httpApi.makeRequest<MetaAndAssetCtxs>(\n          {\n            type: CONSTANTS.InfoType.PERPS_META_AND_ASSET_CTXS,\n          },\n          20\n        ), // Correct weight according to Hyperliquid documentation\n        this.httpApi.makeRequest<SpotMetaAndAssetCtxs>(\n          {\n            type: CONSTANTS.InfoType.SPOT_META_AND_ASSET_CTXS,\n          },\n          20\n        ), // Correct weight according to Hyperliquid documentation\n      ]);\n\n      // Verify responses are valid before proceeding\n      if (\n        !perpMeta ||\n        !perpMeta[0] ||\n        !perpMeta[0].universe ||\n        !Array.isArray(perpMeta[0].universe)\n      ) {\n        throw new Error('Invalid perpetual metadata response');\n      }\n\n      if (\n        !spotMeta ||\n        !spotMeta[0] ||\n        !spotMeta[0].tokens ||\n        !Array.isArray(spotMeta[0].tokens) ||\n        !spotMeta[0].universe ||\n        !Array.isArray(spotMeta[0].universe)\n      ) {\n        throw new Error('Invalid spot metadata response');\n      }\n\n      this.assetToIndexMap.clear();\n      this.exchangeToInternalNameMap.clear();\n\n      // Handle perpetual assets\n      perpMeta[0].universe.forEach((asset: { name: string }, index: number) => {\n        const internalName = `${asset.name}-PERP`;\n        this.assetToIndexMap.set(internalName, index);\n        this.exchangeToInternalNameMap.set(asset.name, internalName);\n      });\n\n      // Handle spot assets\n      spotMeta[0].tokens.forEach((token: any) => {\n        const universeItem = spotMeta[0].universe.find(\n          (item: any) => item.tokens[0] === token.index\n        );\n        if (universeItem) {\n          const internalName = `${token.name}-SPOT`;\n          const exchangeName = universeItem.name;\n          const index = universeItem.index;\n          this.assetToIndexMap.set(internalName, 10000 + index);\n          this.exchangeToInternalNameMap.set(exchangeName, internalName);\n        }\n      });\n\n      // Reset consecutive failures counter on success\n      this.consecutiveFailures = 0;\n    } catch (error) {\n      // Increment consecutive failures counter\n      this.consecutiveFailures++;\n\n      // Check if we've reached the maximum number of consecutive failures\n      this.checkMaxFailures();\n\n      // Propagate the error to be handled by the caller\n      throw error;\n    }\n  }\n\n  public async getExchangeName(internalName: string): Promise<string | undefined> {\n    await this.ensureInitialized();\n    for (const [exchangeName, name] of this.exchangeToInternalNameMap.entries()) {\n      if (name === internalName) {\n        return exchangeName;\n      }\n    }\n    return undefined;\n  }\n\n  public async getAssetIndex(assetSymbol: string): Promise<number | undefined> {\n    await this.ensureInitialized();\n    return this.assetToIndexMap.get(assetSymbol);\n  }\n\n  public async getAllAssets(): Promise<{ perp: string[]; spot: string[] }> {\n    await this.ensureInitialized();\n    const perp: string[] = [];\n    const spot: string[] = [];\n\n    for (const [asset, index] of this.assetToIndexMap.entries()) {\n      if (asset.endsWith('-PERP')) {\n        perp.push(asset);\n      } else if (asset.endsWith('-SPOT')) {\n        spot.push(asset);\n      }\n    }\n\n    return { perp, spot };\n  }\n\n  async convertSymbol(symbol: string, mode: string = '', symbolMode: string = ''): Promise<string> {\n    await this.ensureInitialized();\n    let rSymbol: string;\n    if (mode === 'reverse') {\n      for (const [key, value] of this.exchangeToInternalNameMap.entries()) {\n        if (value === symbol) {\n          return key;\n        }\n      }\n      rSymbol = symbol;\n    } else {\n      rSymbol = this.exchangeToInternalNameMap.get(symbol) || symbol;\n    }\n\n    if (symbolMode === 'SPOT') {\n      if (!rSymbol.endsWith('-SPOT')) {\n        rSymbol = symbol + '-SPOT';\n      }\n    } else if (symbolMode === 'PERP') {\n      if (!rSymbol.endsWith('-PERP')) {\n        rSymbol = symbol + '-PERP';\n      }\n    }\n\n    return rSymbol;\n  }\n\n  async convertSymbolsInObject(\n    obj: any,\n    symbolsFields: Array<string> = ['coin', 'symbol'],\n    symbolMode: string = ''\n  ): Promise<any> {\n    await this.ensureInitialized();\n    if (typeof obj !== 'object' || obj === null) {\n      return this.convertToNumber(obj);\n    }\n\n    if (Array.isArray(obj)) {\n      return Promise.all(\n        obj.map(item => this.convertSymbolsInObject(item, symbolsFields, symbolMode))\n      );\n    }\n\n    const convertedObj: any = {};\n    for (const [key, value] of Object.entries(obj)) {\n      if (symbolsFields.includes(key)) {\n        convertedObj[key] = await this.convertSymbol(value as string, '', symbolMode);\n      } else if (key === 'side') {\n        convertedObj[key] = value === 'A' ? 'sell' : value === 'B' ? 'buy' : value;\n      } else {\n        convertedObj[key] = await this.convertSymbolsInObject(value, symbolsFields, symbolMode);\n      }\n    }\n    return convertedObj;\n  }\n\n  convertToNumber(value: any): any {\n    if (typeof value === 'string') {\n      if (/^-?\\d+$/.test(value)) {\n        return parseInt(value, 10);\n      } else if (/^-?\\d*\\.\\d+$/.test(value)) {\n        return parseFloat(value);\n      }\n    }\n    return value;\n  }\n\n  async convertResponse(\n    response: any,\n    symbolsFields: string[] = ['coin', 'symbol'],\n    symbolMode: string = ''\n  ): Promise<any> {\n    return this.convertSymbolsInObject(response, symbolsFields, symbolMode);\n  }\n}\n"],"mappings":"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","names":["index_exports","__export","BASE_URLS","CHAIN_IDS","ENDPOINTS","ExchangeType","Hyperliquid","InfoType","SDK_CODE","WEBSOCKET","WSS_URLS","cancelOrderToAction","floatToIntForHashing","floatToUsdInt","floatToWire","getTimestampMs","normalizeTrailingZeros","orderToWire","orderTypeToWire","orderWireToAction","removeTrailingZeros","signAgent","signL1Action","signUsdTransferAction","signUserSignedAction","signWithdrawFromBridgeAction","__toCommonJS","BASE_URLS","WSS_URLS","CHAIN_IDS","ENDPOINTS","InfoType","ExchangeType","WEBSOCKET","SDK_CODE","GeneralInfoAPI","httpApi","symbolConversion","parent","rawResponse","response","convertedResponse","key","value","convertedKey","convertedValue","user","startTime","endTime","params","oid","coin","nSigFigs","mantissa","interval","builder","vaultAddress","source","aggregateByTime","builderAddress","SpotInfoAPI","httpApi","symbolConversion","rawResponse","response","user","tokenId","PerpetualsInfoAPI","httpApi","symbolConversion","parent","rawResponse","response","user","startTime","endTime","coin","symbol","dex","responseData","convertedResponse","cap","import_axios","HyperliquidAPIError","code","message","AuthenticationError","handleApiError","error","errorCode","errorMessage","HttpApi","baseUrl","endpoint","rateLimiter","axios","payload","weight","response","error","handleApiError","InfoAPI","baseURL","rateLimiter","symbolConversion","parent","HttpApi","ENDPOINTS","GeneralInfoAPI","SpotInfoAPI","PerpetualsInfoAPI","assetName","exchangeName","rawResponse","user","startTime","endTime","oid","coin","nSigFigs","mantissa","interval","builder","vaultAddress","source","aggregateByTime","builderAddress","import_ethers","import_msgpack","import_ethers","phantomDomain","agentTypes","orderTypeToWire","orderType","floatToWire","addressToBytes","address","actionHash","action","vaultAddress","nonce","normalizedAction","normalizeTrailingZeros","msgPackBytes","additionalBytesLength","data","view","constructPhantomAgent","hash","isMainnet","signL1Action","wallet","activePool","phantomAgent","signInner","signUserSignedAction","payloadTypes","primaryType","signUsdTransferAction","signWithdrawFromBridgeAction","signAgent","signature","splitSig","sig","r","s","v","x","rounded","normalized","removeTrailingZeros","value","floatToIntForHashing","floatToInt","floatToUsdInt","power","withDecimals","getTimestampMs","orderToWire","order","asset","orderWire","orderWireToAction","orders","grouping","builder","obj","item","result","key","cancelOrderToAction","cancelRequest","ExchangeAPI","testnet","privateKey","info","rateLimiter","symbolConversion","walletAddress","parent","vaultAddress","baseURL","BASE_URLS","HttpApi","ENDPOINTS","symbol","index","orderRequest","_a","_b","grouping","builder","ordersArray","assetIndexCache","normalizedOrders","order","normalizedOrder","removeTrailingZeros","orderWires","o","assetIndex","orderToWire","actions","orderWireToAction","nonce","signature","signL1Action","payload","error","cancelRequests","cancels","cancelsWithIndices","req","action","a","cloid","oid","orderWire","modifies","assetIndices","m","normalizedModifies","leverageMode","leverage","isBuy","ntli","destination","amount","CHAIN_IDS","signUsdTransferAction","token","signUserSignedAction","signWithdrawFromBridgeAction","usdc","toPerp","time","isDeposit","usd","name","description","initialUsd","allowDeposits","alwaysCloseOnWithdraw","code","SDK_CODE","usingBigBlocks","twapWire","cancelRequest","request","signAgent","builderAddress","displayName","optOut","wei","validator","isUndelegate","subAccountUser","weight","timestamp","environment","nodeVersion","_a","WebSocket","req","WebSocketClient","testnet","maxReconnectAttempts","_a","WSS_URLS","environment","ws","req","_b","resolve","reject","nodeVersion","event","message","error","delay","timer","err","manualDisconnect","handler","handlers","args","WebSocketSubscriptions","ws","symbolConversion","type","params","key","callback","_a","callbacks","subscription","subscriptionKey","error","convertedSubscription","message","channel","additionalChecks","data","convertedData","messageHandler","value","convertedKey","convertedValue","user","coin","interval","convertedCoin","convertedMessage","requestType","payload","timeout","id","convertedPayload","convertCoinToExchangeFormat","order","cancel","request","resolve","reject","receivedMessages","timeoutId","responseHandler","responseData","processResponse","item","result","processedResponse","subscriptionsToRestore","details","EXCHANGE_METHOD_CONFIGS","params","context","orders","grouping","wireOrders","order","normalizedOrder","removeTrailingZeros","assetIndex","orderToWire","cancels","cancelsWithIndices","cancel","oid","CHAIN_IDS","PayloadGenerator","methodName","config","action","nonce","vaultAddress","signature","signL1Action","signUserSignedAction","signAgent","signUsdTransferAction","payload","error","errorMessage","WebSocketPayloadManager","config","context","PayloadGenerator","coin","index","methodName","params","timeout","payload","error","errorMessage","orderParams","orders","grouping","cancelParams","cancels","modifyParams","amount","toPerp","destination","token","vaultAddress","isDeposit","usd","agentAddress","agentName","builder","maxFeeRate","twapParams","time","wei","symbol","isBuy","size","px","slippage","cloid","createWebSocketPayloadManager","RateLimiter","now","newTokens","weight","waitTimeMs","resolve","import_ethers","CustomOperations","exchangeOrParent","infoApiOrPrivateKey","privateKeyOrSymbolConversion","symbolConversionOrWalletAddress","walletAddress","Hyperliquid","_a","symbol","address","openOrders","ordersToCancel","order","cancelRequests","error","isBuy","slippage","px","convertedSymbol","allMids","isSpot","decimals","size","cloid","slippagePrice","orderRequest","positions","position","item","szi","closeSize","closeOrders","import_ethers","SymbolConversion","baseURL","rateLimiter","disableAssetMapRefresh","refreshIntervalMs","HttpApi","ENDPOINTS","error","exchangeName","intervalMs","perpMeta","spotMeta","asset","index","internalName","token","universeItem","item","name","assetSymbol","perp","spot","symbol","mode","symbolMode","rSymbol","key","value","obj","symbolsFields","convertedObj","response","Hyperliquid","params","enableWs","privateKey","testnet","walletAddress","vaultAddress","maxReconnectAttempts","disableAssetMapRefresh","assetMapRefreshIntervalMs","environment","BASE_URLS","RateLimiter","SymbolConversion","InfoAPI","CustomOperations","WebSocketClient","WebSocketSubscriptions","wsError","errorMessage","error","formattedPrivateKey","ExchangeAPI","Class","target","prop","AuthenticationError","wallet","createWebSocketPayloadManager","intervalMs"]}